<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bureau du Prof</title>

<style>
        /* --- CHARTE GRAPHIQUE --- */
        :root {
            --bg-color: #eef2f5;
            --widget-bg: #ffffff;
            --primary-color: #4a90e2;
            --text-color: #333;
            --shadow: 0 8px 24px rgba(149, 157, 165, 0.2);
            --border-radius: 18px;
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #1a1a2e; /* fond derri√®re le board quand la fen√™tre est plus haute */
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
        }

        #board { 
            position: absolute;
            background-color: var(--bg-color);
            z-index: 0; 
            transition: background 0.3s ease;
            overflow: hidden;
        }

        /* --- WIDGETS --- */
        .widget {
            position: absolute;
            background: var(--widget-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            z-index: 1;
            border: 2px solid transparent;
            height: auto;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
            box-sizing: border-box;
        }

        .widget:focus-within { border-color: var(--primary-color); box-shadow: 0 12px 30px rgba(74, 144, 226, 0.3); }
        .widget[data-type="homework"]:focus-within { border-color: #ff4757; }
        .widget[data-type="iframe"]:focus-within { border-color: #2bcbba; }

        /* --- WIDGETS TRANSPARENTS --- */
        .widget[data-transparent="true"] {
            border: none !important;
            box-shadow: none !important;
            background: transparent !important;
        }

        .widget[data-transparent="true"]:hover,
        .widget[data-transparent="true"]:focus-within {
            background: rgba(74, 144, 226, 0.05) !important;
        }

        .widget[data-transparent="true"] .editor-container,
        .widget[data-transparent="true"] .editor-content {
            border: none !important;
            background: transparent !important;
        }

        /* --- CONTR√îLES ISOL√âS --- */
        .widget-header { display: none !important; }

        .drag-handle, .widget-close-handle, .widget-pin-handle {
            position: absolute;
            width: 26px;
            height: 26px;
            background: #f8f9fa;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
        }

        .drag-handle { 
            left: -13px; 
            top: 50%; 
            transform: translateY(-50%); 
            cursor: move; 
            font-size: 14px; 
            color: #666; 
        }
        .widget-close-handle { top: 5px; right: 5px; }
        .widget-pin-handle { top: 5px; right: 35px; cursor: pointer; font-size: 14px; color: #666; }

        .widget:focus-within .drag-handle,
        .widget:focus-within .widget-close-handle,
        .widget:focus-within .widget-pin-handle {
            opacity: 1;
            pointer-events: auto;
        }

        .widget-close-handle:hover { color: #ff5f56; background: white; }
        .drag-handle:hover { color: var(--primary-color); background: white; }
        .widget-pin-handle:hover { background: white; }

        .widget.pinned .widget-pin-handle { background: #FFD230; transform: rotate(-45deg); }
        .widget.pinned { border: 2px solid transparent !important; }

        /* --- CONTENU & √âDITEUR --- */
        .widget[data-type="date"], .widget[data-type="time"] { min-width: unset; width: auto; }

        .widget[data-type="date"] .editor-container,
        .widget[data-type="time"] .editor-container {
            resize: none;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: white;
        }

        .widget[data-type="date"]:hover .editor-container,
        .widget[data-type="time"]:hover .editor-container { resize: both; }

        /* Les dimensions initiales sont pos√©es en style inline dans les templates */
        /* et sauvegard√©es/restaur√©es en % par saveBoard/loadBoard.               */
        .widget[data-type="date"] .editor-container { min-width: 150px; min-height: 180px; }
        .widget[data-type="time"] .editor-container { min-width: 120px; min-height: 80px; }

        .editor-toolbar { 
            display: flex;
            visibility: hidden; 
            opacity: 0; 
            gap: 4px; 
            padding: 0px 35px; 
            background: #f8f9fa; 
            border-bottom: 1px solid #eee; 
            flex-wrap: wrap; 
            align-items: center; 
            min-height: 36px;
        }
        .widget:focus-within .editor-toolbar { visibility: visible; opacity: 1; }

        .widget-content { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }

        .editor-container { 
            display: flex; flex-direction: column; border: 1px solid #eee; border-radius: 8px; background: white; 
            flex-grow: 1; overflow: hidden; resize: none; min-width: 80px; min-height: 50px;
        }

        .widget:hover .editor-container { resize: both; }
        .editor-container::-webkit-resizer { background-color: transparent; }
        .widget:hover .editor-container::-webkit-resizer { 
            background-color: #ccc; 
            background-image: linear-gradient(135deg, transparent 50%, #333 50%, #333 60%, transparent 60%, transparent 70%, #333 70%, #333 80%, transparent 80%);
        }

        .editor-toolbar button, .editor-toolbar select, .editor-toolbar input { 
            padding: 2px 4px; cursor: pointer; border: 1px solid #ddd; background: white; 
            border-radius: 4px; font-size: 11px; height: 26px; box-sizing: border-box;
        }
        
        @font-face { font-family: 'KGPerfectPenmanship'; src: url('./KGPerfectPenmanship.ttf') format('truetype'); }
        @font-face { font-family: 'Andika'; src: url('./Andika.ttf') format('truetype'); }
        @font-face { font-family: 'OpenDyslexicLocal'; src: url('./OpenDyslexic-Regular.otf') format('opentype'); }
        @font-face { font-family: 'BelleAllureGS'; src: url('BelleAllureGS-Gros.otf') format('opentype'); }

        .editor-content { padding: 10px; outline: none; overflow: auto; text-align: left; flex-grow: 1; }

        /* --- TOOLBAR & MENU PRINCIPAL --- */
        #toolbar-container { position: fixed; bottom: 30px; left: 30px; display: flex; flex-direction: column; align-items: flex-start; z-index: 9999; }
        
        #tools-menu { 
            display: none; background: #1F1F21; border-radius: 12px; padding: 10px; box-shadow: var(--shadow); 
            margin-bottom: 15px; flex-direction: column; gap: 8px; min-width: 180px; border: 1px solid #eee; 
            position: relative; max-height: 70vh; overflow-y: auto; overflow-x: hidden;
        }
        #tools-menu.active { display: flex; }
        
        #bg-submenu {
            display: none; position: fixed; left: 220px; bottom: 80px; background: white; border-radius: 12px; 
            padding: 12px; box-shadow: var(--shadow); grid-template-columns: repeat(3, 1fr); gap: 10px; 
            min-width: 240px; border: 1px solid #eee; z-index: 10001;
        }
        #bg-submenu.active { display: grid; }

        @media (max-width: 600px) {
            #bg-submenu { left: 30px; bottom: 120px; min-width: 200px; grid-template-columns: repeat(2, 1fr); }
        }
        
        .tool-btn { background: var(--primary-color); color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        .tool-btn2 { width: 100%; padding: 10px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 8px; transition: filter 0.2s; }

        #main-tool-btn { background: #333; width: 80px; justify-content: center; }

        .exit-fs-btn { display: none; position: absolute; top: 10px; right: 10px; z-index: 99999; background: rgba(0, 0, 0, 0.5); color: white; border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 14px; }
        :fullscreen .exit-fs-btn { display: block; }

        .bg-thumb { width: 70px; height: 50px; border-radius: 6px; border: 2px solid #eee; cursor: pointer; background-size: cover; background-position: center; transition: 0.2s; }
        .bg-thumb:hover { transform: scale(1.05); border-color: var(--primary-color); }
        
		#draw-canvas {
			position: absolute;
			top: 0; left: 0;
			z-index: 500;
			cursor: crosshair;
			touch-action: none;
		}
		#draw-canvas.inactive {
			pointer-events: none;
			cursor: default;
		}

		.widget.selected {
			outline: 3px dashed #f39c12 !important;
			outline-offset: 4px;
		}

		#selection-rect {
			position: absolute;
			border: 2px dashed #f39c12;
			background: rgba(243, 156, 18, 0.08);
			pointer-events: none;
			z-index: 600;
			display: none;
		}

        /* --- CALENDRIER & HORLOGE --- */
        /* Les font-size sont en em, relatifs √† la taille de base pos√©e en style inline   */
        /* sur .calendar-page et .clock-time, scal√©e par scaleFontSizesBy() au resize.    */
        .calendar-page { width: 100%; height: 100%; display: flex; flex-direction: column; border: 1px solid #ced4da; border-radius: 8px; overflow: hidden; background: white; text-align: center; position: relative; padding-top: 15px; box-sizing: border-box; }
        .calendar-page::before { content: "‚óè ‚óè ‚óè"; position: absolute; top: -8px; left: 0; right: 0; color: #8e9aaf; font-size: 1.5em; letter-spacing: 0.9em; text-shadow: 0 5px 0 #6c757d; }
        .calendar-header { background: #D17B6B; height: 20%; min-height: 30px; border-bottom: 2px solid #D17B6B; margin-bottom: 5px; }
        .calendar-body { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; padding: 5px; }
        .calendar-day-name   { font-size: 0.75em;  font-weight: 700; color: #333; text-transform: lowercase; }
        .calendar-day-number { font-size: 2.2em;   font-weight: 800; color: #2c3e50; line-height: 1em; margin: 0.12em 0; }
        .calendar-month      { font-size: 0.95em;  font-weight: 600; color: #333; }

        .clock-time { font-weight: 800; color: var(--primary-color); font-family: 'Courier New', monospace; display: flex; align-items: baseline; justify-content: center; width: 100%; gap: 4px; }
        .clock-seconds { font-size: 0.5em; color: #888; margin-left: 0.1em; }

        .icon-transparency { display: inline-block; width: 16px; height: 16px; border: 1px solid #333; background-color: #fff; background-image: linear-gradient(45deg, #ddd 25%, transparent 25%), linear-gradient(-45deg, #ddd 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ddd 75%), linear-gradient(-45deg, transparent 75%, #ddd 75%); background-size: 8px 8px; background-position: 0 0, 0 4px, 4px -4px, -4px 0px; vertical-align: middle; border-radius: 2px; }
        
        /* --- STYLE DU WIDGET AGENDA --- */
        /* Toutes les tailles sont en em, relatives √† la taille de base de .agenda-container */
        /* La taille de base (font-size sur .agenda-container) est d√©finie en style inline  */
        /* et scal√©e par scaleFontSizesBy() comme n'importe quel autre widget.              */
        .agenda-container { display: flex; flex-direction: column; background: #fff; border-radius: 8px; border: 1px solid #eee; overflow: hidden; min-height: 200px; }
        .agenda-header-title { background: #2b7fff; color: white; padding: 10px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; font-family: 'Segoe UI', sans-serif; border-radius: 4px 4px 0 0; font-size: 1em; }
        .agenda-current-time { background: rgba(255, 255, 255, 0.2); padding: 2px 8px; border-radius: 4px; font-size: 0.9em; }
        .agenda-header-date, .agenda-header-time { display: inline-block; }
        .agenda-header-time { font-family: monospace; background: rgba(255, 255, 255, 0.2); padding: 2px 6px; border-radius: 4px; margin-left: 10px; }
        .agenda-list { padding: 10px; flex-grow: 1; }
        .agenda-item { display: flex; align-items: center; gap: 10px; padding: 5px 0; border-bottom: 1px dashed #eee; position: relative; }
        .agenda-item:last-child { border-bottom: none; }
        .agenda-item.dragging { opacity: 0.5; background: #f0f7ff; border: 1px dashed var(--primary-color); }
        .agenda-time { font-weight: bold; color: #4a90e2; font-size: 1.2em; min-width: 45px; outline: none; cursor: text; }
        .agenda-text { outline: none; flex-grow: 1; font-size: 1.2em; color: #333; }
        .agenda-add-btn { background: #f8f9fa; border: none; border-top: 1px solid #eee; padding: 5px; cursor: pointer; color: #4a90e2; font-weight: bold; font-size: 1.2em; transition: background 0.2s; }
        .agenda-add-btn:hover { background: #eef2f5; color: #2c3e50; }
        .agenda-row-handle { cursor: grab; color: #ccc; padding: 0 5px; font-size: 0.75em; user-select: none; }
        .agenda-row-handle:active { cursor: grabbing; }
        .agenda-delete-row { cursor: pointer; color: #e74c3c; font-weight: bold; font-size: 1em; padding: 0 5px; opacity: 0; transition: opacity 0.2s; }
        .agenda-item:hover .agenda-delete-row { opacity: 1; }
        .agenda-delete-row:hover { transform: scale(1.2); }
        
        /* --- MODALES --- */
        #modal-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:20000; justify-content:center; align-items:center; }
        .modal-content { background:white; padding:30px; border-radius:var(--border-radius); box-shadow:var(--shadow); text-align:center; max-width:400px; width:90%; }
        .modal-content button { padding: 10px 20px; border-radius: 10px; font-weight: 600; cursor: pointer; }
        .modal-content .btn-cancel { border: 1px solid #ddd; background: #f8f9fa; color: var(--text-color); }
        .modal-content .btn-confirm { border: none; background: #ff4757; color: white; }
    </style>
</head>
<body>

    <div id="board"></div>

    <div id="toolbar-container">

		<div id="tools-menu">
			<button class="tool-btn" onclick="createWidget('youtube'); toggleMenu()" style="background: #E7180B;"><span>üé¨</span> Vid√©o YouTube</button>
			<button class="tool-btn" onclick="createWidget('outilsprofs'); toggleMenu()" style="background: #FF692A;"><span>üéí</span> OutilsProfs</button>
			<button class="tool-btn" onclick="createWidget('iframe'); toggleMenu()" style="background: #FFD230;"><span>üíª</span> Fen√™tre Web</button>
			<button class="tool-btn" onclick="createWidget('time'); toggleMenu()" style="background: #7CCF35;"><span>üïí</span> Heure</button>
			<button class="tool-btn" onclick="createWidget('date'); toggleMenu()" style="background: #679638;"><span>üìÖ</span> Date</button>
			<button class="tool-btn" onclick="createWidget('homework'); toggleMenu()" style="background: #3BB8DB;"><span>üìù</span> Devoirs</button>
			<button class="tool-btn" onclick="createWidget('text'); toggleMenu()" style="background: #2B7FFF;"><span>üñäÔ∏è</span> Texte</button>
			<button class="tool-btn" onclick="createWidget('agenda'); toggleMenu()" style="background: #8E51FF">üìå Planning</button>
			<button class="tool-btn" onclick="createWidget('deficalme'); toggleMenu()" style="background: #480eb3;"><span>üßò</span> D√©fi Calme</button>
			<hr style="width: 100%; border: 0; border-top: 1px solid #eee; margin: 5px 0;">
			<button class="tool-btn" style="background: #71717B;" onclick="toggleSubMenu(event)"><span>üñºÔ∏è</span> Choisir fond ‚ùØ</button>
			<div id="bg-submenu">
				<div class="bg-thumb" style="background-color: #eef2f5;" onclick="applyBackground('none'); saveBg('none')" title="D√©faut"></div>
				<div class="bg-thumb" style="background-color: #2f3542;" onclick="applyBackground('#2f3542'); saveBg('#2f3542')" title="Ardoise"></div>
				<div class="bg-thumb" style="background-color: #104626;" onclick="applyBackground('#104626'); saveBg('#104626')" title="Vert Tableau"></div>
				<div class="bg-thumb" style="background-color: #BAA09B;" onclick="applyBackground('#BAA09B'); saveBg('#BAA09B')" title="Vieux rose"></div>
				<div class="bg-thumb" style="background-image: url('https://www.transparenttextures.com/patterns/grid-me.png');" onclick="applyBackground('url(https://www.transparenttextures.com/patterns/grid-me.png)'); saveBg('url(https://www.transparenttextures.com/patterns/grid-me.png)')" title="Carreaux"></div>
				<div class="bg-thumb" style="background-image: url('https://www.transparenttextures.com/patterns/lined-paper.png');" onclick="applyBackground('url(https://www.transparenttextures.com/patterns/lined-paper.png)'); saveBg('url(https://www.transparenttextures.com/patterns/lined-paper.png)')" title="Lignes"></div>
				<div class="bg-thumb" style="background-image: url('https://www.transparenttextures.com/patterns/arches.png');" onclick="applyBackground('url(https://www.transparenttextures.com/patterns/arches.png)'); saveBg('url(https://www.transparenttextures.com/patterns/arches.png)')" title="Arches"></div>
				<div class="bg-thumb" style="background-image: url('https://www.transparenttextures.com/patterns/shattered.png');" onclick="applyBackground('url(https://www.transparenttextures.com/patterns/shattered.png)'); saveBg('url(https://www.transparenttextures.com/patterns/shattered.png)')" title="√âclats"></div>
				<button class="tool-btn" onclick="document.getElementById('bg-upload').click()" style="background: #8e44ad; padding: 5px; font-size: 10px; grid-column: span 3; border-radius: 8px;"><span>üì∑</span> Importer image</button>
			</div>
		</div>

		<div id="draw-toolbar" style="display: none; position: fixed; bottom: 80px; left: 30px; background: #1F1F21; border-radius: 12px; padding: 12px 16px; box-shadow: 0 -4px 20px rgba(0,0,0,0.3); z-index: 9998; border: 1px solid #444;">
			<div style="display: flex; align-items: center; gap: 14px; flex-wrap: wrap;">
				<span style="color: #ccc; font-size: 12px; font-weight: 600;">‚úèÔ∏è Dessin</span>
				<span style="color: #ccc; font-size: 11px;">Couleur :</span>
				<input type="color" id="draw-color" value="#e84393" style="width: 32px; height: 28px; border: none; cursor: pointer; background: none;">
				<span style="color: #ccc; font-size: 11px;">√âpaisseur :</span>
				<input type="range" id="draw-size" min="1" max="40" value="4" style="width: 90px; cursor: pointer;">
				<span id="draw-size-label" style="color: #fff; font-size: 12px; min-width: 20px;">4</span>
				<button onclick="clearCanvas()" style="background: #ff4757; color: white; border: none; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px;">üóëÔ∏è Effacer</button>
				<button onclick="stopDrawing()" style="background: #6c757d; color: white; border: none; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px;">‚úñ Fermer</button>
			</div>
		</div>

		<div id="select-toolbar" style="display: none; position: fixed; bottom: 80px; left: 30px; background: #1F1F21; border-radius: 12px; padding: 12px 16px; box-shadow: 0 -4px 20px rgba(0,0,0,0.3); z-index: 9998; border: 1px solid #444;">
			<div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
				<span style="color: #ccc; font-size: 12px; font-weight: 600;">üî≤ S√©lection</span>
				<button id="obj-btn" onclick="activateSelectObj()" style="background: #f39c12; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px;">üñ±Ô∏è Objet</button>
				<button id="zone-btn" onclick="activateSelectZone()" style="background: #f39c12; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 13px;">‚¨ö Zone</button>
				<div style="width: 1px; height: 24px; background: #444;"></div>
				<button id="move-btn" onclick="toggleMoveMode()" style="background: #2B7FFF; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: not-allowed; opacity: 0.4; font-size: 13px;">‚ú• D√©placer</button>
				<button id="rotate-btn" onclick="toggleRotateMode()" style="background: #8E51FF; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: not-allowed; opacity: 0.4; font-size: 13px;">üîÑ Rotation</button>
				<span id="rotate-label" style="color: #fff; font-size: 12px; display: none; min-width: 35px;">0¬∞</span>
				<div style="width: 1px; height: 24px; background: #444;"></div>
				<button id="delete-btn" onclick="deleteSelected()" style="background: #ff4757; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: not-allowed; opacity: 0.4; font-size: 13px;">üóëÔ∏è Supprimer</button>
				<button onclick="stopSelectMode()" style="background: #6c757d; color: white; border: none; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 13px;">‚úñ Fermer</button>
			</div>
		</div>

		<div id="global-toolbar" style="position: fixed; bottom: 80px; left: 30px; right: 30px; background: #1F1F21; border-radius: 12px; display: none; padding: 10px 15px; box-shadow: 0 -4px 20px rgba(0,0,0,0.3); z-index: 9998; border: 1px solid #444;">
			<div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
				<button onmousedown="savedSelection = saveCurrentSelection()" onclick="formatGlobal('bold')" title="Gras"><b>G</b></button>
				<button onmousedown="savedSelection = saveCurrentSelection()" onclick="formatGlobal('italic')" title="Italique"><i>I</i></button>
				<button onmousedown="savedSelection = saveCurrentSelection()" onclick="formatGlobal('underline')" title="Soulign√©"><u>S</u></button>
				<span style="font-size: 10px; color:#ccc;">Texte :</span>
				<input type="color" onmousedown="savedSelection = saveCurrentSelection()" onchange="applyTextColor(this.value)" title="Couleur du texte">
				<span style="font-size: 10px; color:#ccc;">Surligner :</span>
				<input type="color" onmousedown="savedSelection = saveCurrentSelection()" onchange="applyHighlightColor(this.value)" title="Surligner" value="#ffff00">
				<span style="font-size: 10px; color:#ccc;">Fond widget :</span>
				<input type="color" onchange="changeWidgetBgGlobal(this, this.value)" title="Fond du cadre" value="#ffffff">
				<button onmousedown="savedSelection = saveCurrentSelection()" onclick="toggleTransparencyGlobal()" title="Fond transparent"><span class="icon-transparency"></span></button>
				<select onmousedown="savedSelection = saveCurrentSelection()" onchange="formatFontFamilyGlobal(this.value)" style="width: 140px;">
					<option value="Arial, sans-serif">Arial</option>
					<option value="'Segoe UI', sans-serif">Segoe UI</option>
					<option value="'Comic Sans MS', cursive">Comic Sans MS</option>
					<option value="Verdana, sans-serif">Verdana</option>
					<option value="'KGPerfectPenmanship', sans-serif">KGPerfectPenmanship</option>
					<option value="'Andika', sans-serif">Andika</option>
					<option value="'OpenDyslexicLocal', sans-serif">üß© OpenDyslexic</option>
					<option value="'BelleAllureGS', cursive">üìè Belle Allure GS</option>
				</select>
				<input type="number" id="font-size-input" value="40" min="8" max="100"
				  onmousedown="savedSelection = saveCurrentSelection()"
				  onkeydown="if(event.key==='Enter'){applyFontSizeOnBlur(this);this.blur();}"
				  onblur="applyFontSizeOnBlur(this)" style="width: 40px;">
				<button onclick="closeGlobalToolbar()" style="margin-left: auto; background: #6c757d; color: white; padding: 4px 8px; border-radius: 4px;">‚úñ</button>
			</div>
		</div><!-- ‚Üê fermeture correcte de #global-toolbar -->

		<!-- Barre de boutons du bas -->
		<div style="position: fixed; bottom: 30px; left: 0; right: 0; display: flex; align-items: center; padding: 0 30px; gap: 10px; z-index: 9999; pointer-events: none;">
			<div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
				<button id="main-tool-btn" class="tool-btn" onclick="toggleMenu()">MENU</button>
				<button id="undo-btn" class="tool-btn" onclick="undoAction()" style="background: #6c757d; opacity: 0.4; cursor: not-allowed;">‚Ü©Ô∏è Annuler</button>
				<button id="redo-btn" class="tool-btn" onclick="redoAction()" style="background: #6c757d; opacity: 0.4; cursor: not-allowed;">‚Ü™Ô∏è Refaire</button>
				<button id="draw-btn" class="tool-btn" onclick="toggleDrawToolbar()" style="background: #e84393;">‚úèÔ∏è Dessin</button>
				<button id="select-btn" class="tool-btn" onclick="toggleSelectToolbar()" style="background: #f39c12;">üî≤ S√©lectionner</button>
				<button id="toolbar-toggle-btn" class="tool-btn" onclick="toggleGlobalToolbar()" style="background: #2B7FFF;">üñäÔ∏è Texte</button>
			</div>
			<div style="flex: 1;"></div>
			<div style="display: flex; gap: 10px; align-items: center; pointer-events: auto;">
				<button class="tool-btn" onclick="exportConfig()" style="background: #2bcbba;">üíæ Exporter</button>
				<button class="tool-btn" onclick="document.getElementById('import-input').click()" style="background: #2bcbba;">üìÇ Importer</button>
				<input type="file" id="import-input" style="display:none" accept=".json" onchange="importConfig(event)">
				<button class="tool-btn" onclick="clearBoard()" style="background: #ff4757;">‚ùå Effacer tout</button>
			</div>
		</div>

	</div>

    

    <div id="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-top:0; color:#ff4757;">‚ö†Ô∏è Tout effacer ?</h3>
            <p style="color:#666;">Cette action videra votre bureau. C'est irr√©versible.</p>
            <div style="display:flex; gap:10px; justify-content:center; margin-top:20px;">
                <button class="btn-cancel" onclick="closeModal()">Annuler</button>
                <button class="btn-confirm" onclick="confirmClearBoard()">Oui, vider tout</button>
            </div>
        </div>
    </div>

    <script type="text/html" id="toolbar-html">
    <div class="editor-toolbar">
        <button onclick="format('bold')">G</button>
        <button onclick="format('italic')">I</button>
        <button onclick="format('underline')">S</button>
        <span style="font-size: 10px; margin-left: 5px;">Texte :</span>
        <input type="color" onchange="format('foreColor', this.value)" title="Couleur du texte">
        <span style="font-size: 10px; margin-left: 5px;">Surligner :</span>
        <input type="color" onchange="format('backColor', this.value)" title="Surligner" value="#ffff00">
        <span style="font-size: 10px; margin-left: 5px;">Fond :</span>
        <input type="color" onchange="changeWidgetBg(this, this.value)" title="Fond du cadre" value="#ffffff">
        <button onclick="toggleTransparency(this)" title="Fond transparent"><span class="icon-transparency"></span></button>
        <select onchange="formatFontFamily(this.value)" style="width: 140px; margin-left: 5px;">
            <option value="Arial, sans-serif">Arial</option>
            <option value="'Segoe UI', sans-serif">Segoe UI</option>
            <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
            <option value="Verdana, sans-serif">Verdana</option>
            <option value="'KGPerfectPenmanship', sans-serif">KGPerfectPenmanship</option>
            <option value="'Andika', sans-serif">Andika</option>
            <option value="'OpenDyslexicLocal', sans-serif">üß© OpenDyslexic</option>
            <option value="'BelleAllureGS', cursive">üìè Belle Allure GS</option>
        </select>
        <input type="number" value="40" min="8" max="100" onchange="formatFontSize(this.value)" style="width: 40px;">
    </div>
    </script>

    <template id="template-text">
        <div class="editor-container">
            <div class="editor-content" contenteditable="true" oninput="saveBoard()" style="font-size: 40px;"></div>
        </div>
    </template>

    <template id="template-homework">
        <div class="editor-container">
			<div class="editor-content" contenteditable="true" oninput="saveBoard()">
				<span style="color: #D4C9C7; font-size: 25px; font-weight: bold;">‚úçüèª Devoirs √† noter </span><br>
				<p><span style="color: red; background-color: #F7E02A; font-size: 38px; font-weight: bold;">Pour</span></p>
				<p><span style="color: #f7639f; font-size: 35px; font-weight: bold;">&nbsp;&nbsp;üëâüèª CE2 =</span></p>
				<p><span style="color: #12a2e0; font-size: 35px; font-weight: bold;">&nbsp;&nbsp;üëâüèΩ CM2 =</span></p>
				<p><span style="color: #D9C93B; font-size: 35px; font-weight: bold;">&nbsp;&nbsp;üëâ TOUS =</span></p>
			</div>
		</div>
    </template>

    <template id="template-date">
        <div class="editor-container" style="width: 220px; height: 260px;">
            <div class="editor-toolbar" style="justify-content: center; border-bottom: none;">
                <button onclick="toggleTransparency(this)" title="Fond transparent">ü´•</button>
            </div>
            <div class="calendar-page" style="font-size: 16px;">
                <div class="calendar-header"></div>
                <div class="calendar-body">
                    <div class="calendar-day-name"></div>
                    <div class="calendar-day-number"></div>
                    <div class="calendar-month"></div>
                </div>
            </div>
        </div>
    </template>

    <template id="template-time">
        <div class="editor-container" style="width: 200px; height: 100px;">
            <div class="clock-time" style="font-size: 32px;">
                <span class="clock-hm">00:00</span><span class="clock-seconds">00</span>
            </div>
        </div>
    </template>

    <template id="template-iframe">
        <div class="editor-container" style="height: 400px; width: 550px;">
            <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
            <div class="editor-toolbar">
                <input type="text" placeholder="Collez l'URL ici..." style="flex-grow: 1;" onchange="loadIframe(this)">
                <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂</button>
            </div>
            <iframe src="" style="flex-grow: 1; border: none; background: white;" allow="microphone; camera; display-capture; autoplay"></iframe>
        </div>
    </template>

    <template id="template-outilsprofs">
        <div class="editor-container" style="height: 500px; width: 800px;">
            <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
            <div class="editor-toolbar" style="display: flex; justify-content: flex-end;">
                <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂ Plein √©cran</button>
            </div>
            <iframe src="https://ecolebernardet.github.io/outilsprofs" style="flex-grow: 1; border: none; background: white;" allow="microphone; camera; display-capture; autoplay"></iframe>
        </div>
    </template>

    <template id="template-youtube">
        <div class="editor-container" style="height: 350px; width: 600px;">
            <div class="editor-toolbar">
                <input type="text" placeholder="Collez le lien YouTube ici..." style="flex-grow: 1;" onchange="loadYoutube(this)">
                <button onclick="toggleYoutubeView(this, 'none')" title="Mode Audio">üîá Son seul</button>
                <button onclick="toggleYoutubeView(this, 'block')" title="Mode Vid√©o">üì∫ Vid√©o</button>
                <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂</button>
                <button onclick="toggleTransparency(this)" title="Fond transparent"><span class="icon-transparency"></span></button>
            </div>
            <iframe src="" style="flex-grow: 1; border: none; background: #000;" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
        </div>
    </template>

    <template id="template-agenda">
        <div class="editor-container">
            <div class="agenda-container" style="font-size: 16px;">
                <div class="agenda-header-title">
                    <span class="agenda-current-date"></span>
                    <span class="agenda-current-time"></span>
                </div>
                <div class="agenda-list">
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <span class="agenda-time" contenteditable="true">08:30</span>
                        <div class="agenda-text" contenteditable="true">Accueil / Appel / Rituels</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <span class="agenda-time" contenteditable="true">09:15</span>
                        <div class="agenda-text" contenteditable="true">Fran√ßais</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <span class="agenda-time" contenteditable="true">10:20</span>
                        <div class="agenda-text" contenteditable="true">R√©cr√©ation</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">10:45</div>
                        <div class="agenda-text" contenteditable="true">Math√©matiques</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">11:45</div>
                        <div class="agenda-text" contenteditable="true">Fin de la matin√©e</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">---------------------------</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">13:45</div>
                        <div class="agenda-text" contenteditable="true">Rituel / Quart d'heure lecture</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">14:00</div>
                        <div class="agenda-text" contenteditable="true">Mati√®re</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">15:20</div>
                        <div class="agenda-text" contenteditable="true">R√©cr√©ation</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">15:45</div>
                        <div class="agenda-text" contenteditable="true">Mati√®re</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                    <div class="agenda-item" draggable="true" ondragstart="handleRowDragStart(event)" ondragover="handleRowDragOver(event)" ondragend="handleRowDragEnd(event)">
                        <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
                        <div class="agenda-time" contenteditable="true">16:30</div>
                        <div class="agenda-text" contenteditable="true">Fin de la journ√©e</div>
                        <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>
                    </div>
                </div>
                <button class="agenda-add-btn" onclick="addAgendaLine(this)" title="Ajouter une ligne">+</button>
            </div>
        </div>
    </template>
    
    <template id="template-deficalme">
        <div class="editor-container" style="height: 500px; width: 800px;">
            <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
            <div class="editor-toolbar" style="display: flex; justify-content: flex-end;">
                <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂ Plein √©cran</button>
            </div>
            <iframe src="https://ecolebernardet.github.io/lebureauduprof/deficalme.html" style="flex-grow: 1; border: none; background: white;" allow="microphone; camera; display-capture; autoplay"></iframe>
        </div>
    </template>

    <input type="file" id="bg-upload" style="display:none" accept="image/*" onchange="handleBgUpload(this)">

<script>
    let board = document.getElementById('board');
    let history = [];
    let isInitialLoading = true;
	let savedSelection = null;

    window.onload = () => {
		const savedBg = localStorage.getItem('boardBackground');
		if (savedBg) applyBackground(savedBg);
		// Appliquer le ratio 16:9 au board d√®s le d√©part
		applyBoardRatio(window.innerWidth);
		loadBoard();
		setTimeout(() => {
			isInitialLoading = false;
			_lastW = window.innerWidth;

			// ‚úÖ Attacher l'√©couteur apr√®s que le DOM soit charg√©
			const fontSizeInput = document.getElementById('font-size-input');
			if (fontSizeInput) {
				fontSizeInput.addEventListener('focus', () => {
					if (!currentActiveWidget) return;
					const selection = window.getSelection();
					if (selection.rangeCount > 0) {
						savedSelection = selection.getRangeAt(0).cloneRange(); // Sauvegarder la s√©lection
						console.log('S√©lection sauvegard√©e');
					}
				});
			} else {
				console.warn('Champ #font-size-input non trouv√© ‚Äî attente suppl√©mentaire...');
				// Optionnel : r√©essayer apr√®s un d√©lai
				setTimeout(() => {
					const retryInput = document.getElementById('font-size-input');
					if (retryInput) {
						retryInput.addEventListener('focus', () => {
							if (!currentActiveWidget) return;
							const selection = window.getSelection();
							if (selection.rangeCount > 0) {
								savedSelection = selection.getRangeAt(0).cloneRange();
								console.log('S√©lection sauvegard√©e (retry)');
							}
						});
					}
				}, 500);
			}
		}, 1000);
		setInterval(updateClock, 1000);
		window.addEventListener('resize', handleWindowResize);
	};

    // =========================================================================
    // SYST√àME DE SCALING ‚Äî RATIO FIXE 16:9
    //
    // Principe : seule la LARGEUR de fen√™tre pilote tout.
    //   virtualH = newW / (16/9)
    //   factor   = newW / _lastW
    //
    // Tous les positions, dimensions et tailles de police sont recalcul√©es
    // uniquement √† partir de ce ratio de largeur.
    // Le board est toujours affich√© en 16:9 (hauteur = largeur / 1.7778).
    // =========================================================================

    const RATIO = 16 / 9; // 1.7778

    // Largeur m√©moris√©e entre deux resize
    let _lastW = window.innerWidth;

    /** Hauteur virtuelle 16:9 pour une largeur donn√©e */
    function virtualH(w) { return w / RATIO; }

    /**
     * Applique la hauteur virtuelle au board.
     * Si la fen√™tre est plus haute que le 16:9, on centre verticalement.
     */
    function applyBoardRatio(newW) {
        const vh = virtualH(newW);
        const winH = window.innerHeight;
        board.style.width  = newW + 'px';
        board.style.height = vh   + 'px';
        // Centrage vertical si la fen√™tre est plus haute que le 16:9
        board.style.position = 'absolute';
        board.style.top  = Math.max(0, (winH - vh) / 2) + 'px';
        board.style.left = '0';
    }

    /**
     * Multiplie tous les font-size inline (px) d'un widget par un facteur.
     * Traite tous les descendants ET l'√©l√©ment root lui-m√™me.
     */
    function scaleFontSizesBy(widgetEl, factor) {
		if (Math.abs(factor - 1) < 0.001) return;
		widgetEl.querySelectorAll('*').forEach(el => {
			if (!el.style || !el.style.fontSize) return;
			// ‚Üê PLUS de v√©rification data-manual-font-size
			const match = el.style.fontSize.match(/^([\d.]+)px$/);
			if (match) el.style.fontSize = (parseFloat(match[1]) * factor) + 'px';
		});
		if (widgetEl.style && widgetEl.style.fontSize) {
			const match = widgetEl.style.fontSize.match(/^([\d.]+)px$/);
			if (match) widgetEl.style.fontSize = (parseFloat(match[1]) * factor) + 'px';
		}
	}

    /**
     * Applique le scaling depuis la largeur de r√©f√©rence (sauvegarde) vers la largeur courante.
     * Utilis√© au chargement quand la r√©solution courante ‚â† r√©solution de sauvegarde.
     */
    function scaleFontSizesFromRef(widgetEl, refW) {
        const factor = window.innerWidth / refW;
        scaleFontSizesBy(widgetEl, factor);
    }

    // =========================================================================
    // GESTION DU REDIMENSIONNEMENT DE FEN√äTRE
    // =========================================================================

    // =========================================================================
    // UTILITAIRE : hauteur de la toolbar dans un container
    // La toolbar est fixe (UI), seul le contenu doit scaler.
    // =========================================================================

    function getToolbarHeight(container) {
        if (!container) return 0;
        const toolbar = container.querySelector('.editor-toolbar');
        return toolbar ? toolbar.offsetHeight : 0;
    }

    function handleWindowResize() {
        const newW = window.innerWidth;
        const factor = newW / _lastW; // ratio bas√© uniquement sur la largeur

        // 1. Adapter le board au ratio 16:9
        applyBoardRatio(newW);

        // 2. Recalculer positions et dimensions de chaque widget
        const newVH = virtualH(newW);

        document.querySelectorAll('.widget').forEach(w => {
            const container      = w.querySelector('.editor-container');
            const widthPercent   = parseFloat(w.dataset.widthPercent   || 0);
            const contentHPercent = parseFloat(w.dataset.contentHPercent || 0);
            const leftPercent    = parseFloat(w.dataset.leftPercent    || 0);
            const topPercent     = parseFloat(w.dataset.topPercent     || 0);

            if (container) {
                // Largeur : scal√©e √† 100%
                if (widthPercent > 0)
                    container.style.width = (widthPercent / 100) * newW + 'px';

                // Hauteur : contenu scal√© + toolbar fixe
                if (contentHPercent > 0) {
                    const toolbarH = getToolbarHeight(container);
                    container.style.height = ((contentHPercent / 100) * newVH) + toolbarH + 'px';
                }
            }

            // Position du widget (en % de l'espace 16:9)
            if (leftPercent > 0) w.style.left = (leftPercent / 100) * newW  + 'px';
            if (topPercent  > 0) w.style.top  = (topPercent  / 100) * newVH + 'px';

            // Tailles de police : ratio uniquement bas√© sur la largeur
            scaleFontSizesBy(w, factor);
        });

        _lastW = newW;
    }



	// =========================================================================
	// SAUVEGARDE
	// =========================================================================

	function saveBoard() {
		if (isInitialLoading || isUndoing) return;

		// Snapshot de l'√©tat ACTUEL (avant d'√©craser) ‚Üí permet d'annuler vers cet √©tat
		takeSnapshot();

		const curW  = window.innerWidth;
		const curVH = virtualH(curW);
		const widgets = [];

		document.querySelectorAll('.widget').forEach(w => {
			const content    = w.querySelector('.editor-content');
			const agendaList = w.querySelector('.agenda-list');
			const iframe     = w.querySelector('iframe');
			const container  = w.querySelector('.editor-container');

			let htmlContent = null;
			if (agendaList) htmlContent = agendaList.innerHTML;
			else if (content) htmlContent = content.innerHTML;

			let widthPercent = 0, contentHPercent = 0, leftPercent = 0, topPercent = 0;
			if (container) {
				const toolbarH   = getToolbarHeight(container);
				widthPercent     = (container.offsetWidth               / curW)  * 100;
				contentHPercent  = ((container.offsetHeight - toolbarH) / curVH) * 100;
			}
			leftPercent = (w.offsetLeft / curW)  * 100;
			topPercent  = (w.offsetTop  / curVH) * 100;

			w.dataset.widthPercent    = widthPercent;
			w.dataset.contentHPercent = contentHPercent;
			w.dataset.leftPercent     = leftPercent;
			w.dataset.topPercent      = topPercent;

			widgets.push({
				type: w.dataset.type, topPercent, leftPercent, widthPercent, contentHPercent,
				html: htmlContent, iframeSrc: iframe ? iframe.src : null,
				transparent: w.dataset.transparent === "true",
				bgColor: w.dataset.bgColor || "#ffffff",
				pinned: w.dataset.pinned === "true"
			});
		});

		const config = { widgets, refWidth: curW };
		localStorage.setItem('profBoardConfig', JSON.stringify(config));
	}

    function loadBoard() {
        const raw = localStorage.getItem('profBoardConfig');
        if (!raw) return;
        const parsed = JSON.parse(raw);

        // Support du nouveau format { widgets, refWidth } ET de l'ancien format (tableau)
        const parsedData = Array.isArray(parsed) ? parsed : (parsed.widgets || []);
        // Par d√©faut 1920 (r√©f√©rence des templates) si pas de refWidth stock√©
        const refW = parsed.refWidth || 1920;

        const curW  = window.innerWidth;
        const curVH = virtualH(curW);

        parsedData.forEach(w => {
            const widget    = createWidget(w.type, '100px', '100px', false);
            const container = widget.querySelector('.editor-container');

            // Support ancien format (heightPercent) ‚Üí converti en contentHPercent
            // Dans l'ancien format, heightPercent incluait la toolbar (~36px sur curVH)
            // On tente une heuristique : si contentHPercent absent, utiliser heightPercent
            const storedContentH = w.contentHPercent !== undefined ? w.contentHPercent : w.heightPercent;

            widget.dataset.widthPercent    = w.widthPercent    || 0;
            widget.dataset.contentHPercent = storedContentH    || 0;
            widget.dataset.leftPercent     = w.leftPercent     !== undefined ? w.leftPercent : 0;
            widget.dataset.topPercent      = w.topPercent      !== undefined ? w.topPercent  : 0;

            // Dimensions en px : largeur scal√©e, hauteur = contenu scal√© + toolbar fixe
            if (container) {
                if (w.widthPercent > 0)
                    container.style.width = (w.widthPercent / 100) * curW + 'px';
                if (storedContentH > 0) {
                    const toolbarH = getToolbarHeight(container);
                    container.style.height = ((storedContentH / 100) * curVH) + toolbarH + 'px';
                }
            }

            // Position en px √† partir des % et de l'espace 16:9 courant
            if (w.leftPercent !== undefined) widget.style.left = (w.leftPercent / 100) * curW  + 'px';
            if (w.topPercent  !== undefined) widget.style.top  = (w.topPercent  / 100) * curVH + 'px';

            setTimeout(() => {
                const editor     = widget.querySelector('.editor-content');
                const agendaList = widget.querySelector('.agenda-list');

                if (w.html) {
                    if (agendaList) {
                        agendaList.innerHTML = w.html;
                        agendaList.querySelectorAll('.agenda-item').forEach(item => attachAgendaItemEvents(item));
                    } else if (editor) {
                        editor.innerHTML = w.html;
                    }
                }

                const iframe = widget.querySelector('iframe');
                if (w.iframeSrc && iframe) iframe.src = w.iframeSrc;

                if (w.transparent) applyTransparency(widget, true);
                else if (w.bgColor) {
                    widget.style.background = w.bgColor;
                    widget.dataset.bgColor  = w.bgColor;
                }

                if (w.pinned) {
                    widget.dataset.pinned = "true";
                    widget.style.zIndex   = "2000";
                    widget.classList.add('pinned');
                }

                // Scaling des polices : ratio largeur courante / largeur de sauvegarde
                scaleFontSizesFromRef(widget, refW);

            }, 50);
        });
    }

    function exportConfig() {
        const widgets = [];
        document.querySelectorAll('.widget').forEach(w => {
            const content    = w.querySelector('.editor-content');
            const agendaList = w.querySelector('.agenda-list');
            const iframe     = w.querySelector('iframe');
            const container  = w.querySelector('.editor-container');

            let htmlContent = null;
            if (agendaList) htmlContent = agendaList.innerHTML;
            else if (content) htmlContent = content.innerHTML;

            let widthPercent = 0, contentHPercent = 0, leftPercent = 0, topPercent = 0;
            const curW  = window.innerWidth;
            const curVH = virtualH(curW);
            if (container) {
                const toolbarH   = getToolbarHeight(container);
                widthPercent     = (container.offsetWidth               / curW)  * 100;
                contentHPercent  = ((container.offsetHeight - toolbarH) / curVH) * 100;
            }
            leftPercent = (w.offsetLeft / curW)  * 100;
            topPercent  = (w.offsetTop  / curVH) * 100;

            widgets.push({
                type: w.dataset.type, topPercent, leftPercent, widthPercent, contentHPercent,
                html: htmlContent, iframeSrc: iframe ? iframe.src : null,
                transparent: w.dataset.transparent === "true",
                bgColor: w.dataset.bgColor || "#ffffff",
                pinned: w.dataset.pinned === "true"
            });
        });

        const config = {
            widgets,
            background: localStorage.getItem('boardBackground') || 'none',
            refWidth:   window.innerWidth   // seule la largeur est n√©cessaire
        };

        const dateStr  = new Date().toISOString().split('T')[0];
        const fileName = `lebureauduprof_export_${dateStr}.json`;
        const dataStr  = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(config));
        const a = document.createElement('a');
        a.setAttribute("href", dataStr);
        a.setAttribute("download", fileName);
        document.body.appendChild(a);
        a.click();
        a.remove();
    }

    async function importConfig(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                const background = importedData.background || 'none';
                document.querySelectorAll('.widget').forEach(w => w.remove());
                applyBackground(background);
                saveBg(background);
                // Stocker le fichier import√© tel quel (nouveau format avec refWidth/refHeight)
                // loadBoard() sait lire les deux formats (ancien tableau et nouveau objet)
                localStorage.setItem('profBoardConfig', JSON.stringify(importedData));
                loadBoard();
                event.target.value = '';
            } catch (err) {
                alert("Erreur lors de l'importation : " + err.message);
            }
        };
        reader.readAsText(file);
    }

    function clearBoard()    { document.getElementById('modal-overlay').style.display = 'flex'; }
    function closeModal()    { document.getElementById('modal-overlay').style.display = 'none'; }
    function confirmClearBoard() {
        document.querySelectorAll('.widget').forEach(w => w.remove());
        saveBoard();
        closeModal();
    }

    // =========================================================================
    // HORLOGE & DATE
    // =========================================================================

    function updateClock() {
        const now = new Date();
        const optionsDate = { weekday: 'long', day: 'numeric', month: 'long' };
        const dateStr = now.toLocaleDateString('fr-FR', optionsDate);
        const timeStr = now.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
        document.querySelectorAll('.agenda-current-date').forEach(el => el.textContent = dateStr);
        document.querySelectorAll('.agenda-current-time').forEach(el => el.textContent = timeStr);
        updateDateTime();
    }

	
    // =========================================================================
    // GESTION DES WIDGETS
    // =========================================================================

    function togglePin(widget) {
        const isPinned = widget.dataset.pinned === "true";
        widget.dataset.pinned = !isPinned;
        if (!isPinned) {
            widget.style.zIndex = "2000";
            widget.classList.add('pinned');
        } else {
            widget.style.zIndex = "1000";
            widget.classList.remove('pinned');
        }
        saveBoard();
    }

    function bringToFront(widget) {
        if (widget.dataset.pinned === "true") return;
        document.querySelectorAll('.widget').forEach(w => {
            if (w.dataset.pinned !== "true") w.style.zIndex = "1";
        });
        widget.style.zIndex = "1000";
    }

	function findFreePosition() {
		const curW  = window.innerWidth;
		const curVH = virtualH(curW);
		const margin = 20;
		const stepX = 320;
		const stepY = 200;

		// R√©cup√©rer les rectangles de tous les widgets existants
		const occupied = Array.from(document.querySelectorAll('.widget')).map(w => ({
			left:   w.offsetLeft,
			top:    w.offsetTop,
			right:  w.offsetLeft + w.offsetWidth,
			bottom: w.offsetTop  + w.offsetHeight
		}));

		// Tester des positions sur une grille jusqu'√† trouver une case libre
		for (let y = margin; y < curVH - stepY; y += stepY) {
			for (let x = margin; x < curW - stepX; x += stepX) {
				const candidateW = 300;
				const candidateH = 180;
				const overlaps = occupied.some(r =>
					x < r.right  + margin &&
					x + candidateW + margin > r.left &&
					y < r.bottom + margin &&
					y + candidateH + margin > r.top
				);
				if (!overlaps) return { x, y };
			}
		}

		// Fallback : d√©calage en cascade si le bureau est tr√®s charg√©
		const count = document.querySelectorAll('.widget').length;
		return {
			x: (margin + count * 30) % (curW  - 200),
			y: (margin + count * 30) % (curVH - 200)
		};
	}

	function createWidget(type, x = null, y = null, snapshot = true) {

		// Si pas de position fournie, trouver une zone libre
		if (x === null || y === null) {
			const pos = findFreePosition();
			x = pos.x + 'px';
			y = pos.y + 'px';
		}

		const widget = document.createElement('div');
        widget.className  = 'widget';
        widget.dataset.type = type;
        widget.style.left = x;
        widget.style.top  = y;
        widget.tabIndex   = 0;
        widget.addEventListener('mousedown', () => bringToFront(widget));
        widget.innerHTML = `
            <div class="drag-handle" title="D√©placer">‚ú•</div>
            <div class="widget-pin-handle" onclick="togglePin(this.closest('.widget'))" title="√âpingler au premier plan">üìå</div>
            <div class="widget-close-handle" onclick="takeSnapshot(); this.closest('.widget').remove(); saveBoard();" title="Fermer">√ó</div>
            <div class="widget-content"></div>`;
        const contentZone = widget.querySelector('.widget-content');
        const template    = document.getElementById(`template-${type}`);
        contentZone.appendChild(template.content.cloneNode(true));
        const toolbarPlaceholder = widget.querySelector('.editor-toolbar-placeholder');
        if (toolbarPlaceholder) toolbarPlaceholder.innerHTML = document.getElementById('toolbar-html').innerHTML;
        board.appendChild(widget);
        makeDraggable(widget);
        if (type === 'agenda') {
            updateClock();
            widget.querySelectorAll('.agenda-item').forEach(item => attachAgendaItemEvents(item));
        }
        const editor = widget.querySelector('.editor-content');
        if (editor) {
            editor.addEventListener('mouseup', () => syncFontSize(widget));
            editor.addEventListener('keyup',   () => syncFontSize(widget));
        }

        // Scaler les font-size et les dimensions du container √† la r√©solution courante.
        // Les templates sont d√©finis pour une largeur de r√©f√©rence de 1920px.
        // Si on cr√©e le widget sur un √©cran plus petit, tout doit √™tre r√©duit.
        const REF_W = 1920;
        const factor = window.innerWidth / REF_W;
        if (Math.abs(factor - 1) > 0.01) {
            scaleFontSizesBy(widget, factor);
            // Scaler aussi les dimensions initiales du editor-container
            const container = widget.querySelector('.editor-container');
            if (container && container.style.width) {
                const w = parseFloat(container.style.width);
                if (w) container.style.width = (w * factor) + 'px';
            }
            if (container && container.style.height) {
                const h = parseFloat(container.style.height);
                if (h) container.style.height = (h * factor) + 'px';
            }
        }

        if (!isInitialLoading) saveBoard();
        return widget;
    }

    function attachAgendaItemEvents(item) {
        item.querySelectorAll('[contenteditable="true"]').forEach(el => {
            el.addEventListener('mouseenter', () => item.draggable = false);
            el.addEventListener('mouseleave', () => item.draggable = true);
            el.addEventListener('input', saveBoard);
        });
        item.addEventListener('dragstart', handleRowDragStart);
        item.addEventListener('dragover',  handleRowDragOver);
        item.addEventListener('dragend',   handleRowDragEnd);
    }

    function syncFontSize(widget) {
        const toolbar = widget.querySelector('.editor-toolbar');
        if (!toolbar) return;
        const sizeInput = toolbar.querySelector('input[type="number"]');
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
            let container = selection.anchorNode.parentElement;
            let size = window.getComputedStyle(container).fontSize;
            if (size) sizeInput.value = parseInt(size);
        }
    }

    function makeDraggable(elmnt) {
        const handle = elmnt.querySelector('.drag-handle');
        handle.onmousedown = (e) => {
            e.preventDefault();
            bringToFront(elmnt);
            let pos3 = e.clientX, pos4 = e.clientY;
            document.onmousemove = (e) => {
                elmnt.style.top  = (elmnt.offsetTop  - (pos4 - e.clientY)) + "px";
                elmnt.style.left = (elmnt.offsetLeft - (pos3 - e.clientX)) + "px";
                pos3 = e.clientX; pos4 = e.clientY;
            };
            document.onmouseup = () => {
                document.onmousemove = null;
                const curW  = window.innerWidth;
                const curVH = virtualH(curW);
                elmnt.dataset.leftPercent = (elmnt.offsetLeft / curW)  * 100;
                elmnt.dataset.topPercent  = (elmnt.offsetTop  / curVH) * 100;
                saveBoard();
            };
        };
    }


// =========================================================================
// DESSIN LIBRE ‚Äî traits vectoris√©s
// =========================================================================

let drawCanvas    = null;
let drawCtx       = null;
let isPainting    = false;
let isDrawMode    = false;
let strokes       = [];      // tous les traits [ { points, color, size } ]
let currentStroke = null;    // trait en cours

function initCanvas() {
    if (drawCanvas) return;
    drawCanvas = document.createElement('canvas');
    drawCanvas.id = 'draw-canvas';
    resizeCanvas();
    board.appendChild(drawCanvas);
    drawCtx = drawCanvas.getContext('2d');

    drawCanvas.addEventListener('mousedown',  startPaint);
    drawCanvas.addEventListener('mousemove',  paint);
    drawCanvas.addEventListener('mouseup',    endPaint);
    drawCanvas.addEventListener('mouseleave', endPaint);
    drawCanvas.addEventListener('touchstart', e => { e.preventDefault(); startPaint(e.touches[0]); }, { passive: false });
    drawCanvas.addEventListener('touchmove',  e => { e.preventDefault(); paint(e.touches[0]); },      { passive: false });
    drawCanvas.addEventListener('touchend',   endPaint);

    document.getElementById('draw-size').addEventListener('input', function() {
        document.getElementById('draw-size-label').textContent = this.value;
    });
}

function resizeCanvas() {
    if (!drawCanvas) return;
    drawCanvas.width  = board.offsetWidth;
    drawCanvas.height = board.offsetHeight;
    redrawStrokes();
}

function getPos(e) {
    const rect = drawCanvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

function startPaint(e) {
    if (!isDrawMode) return;
    isPainting = true;
    const pos = getPos(e);
    currentStroke = {
        points: [pos],
        color:  document.getElementById('draw-color').value,
        size:   parseInt(document.getElementById('draw-size').value)
    };
}

function paint(e) {
    if (!isPainting || !isDrawMode || !currentStroke) return;
    const pos = getPos(e);
    currentStroke.points.push(pos);
    redrawStrokes(currentStroke);
}

function endPaint() {
    if (!isPainting || !currentStroke) return;
    isPainting = false;
    if (currentStroke.points.length > 1) strokes.push(currentStroke);
    currentStroke = null;
    redrawStrokes();
}

function redrawStrokes(extraStroke = null) {
    if (!drawCtx) return;
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    const all = extraStroke ? [...strokes, extraStroke] : strokes;
    all.forEach(stroke => drawStroke(stroke));
    // Surligner les traits s√©lectionn√©s
    selectedStrokes.forEach(stroke => drawStroke(stroke, true));
}

function drawStroke(stroke, highlight = false) {
    if (!stroke.points || stroke.points.length < 2) return;
    drawCtx.save();
    drawCtx.beginPath();
    drawCtx.lineCap   = 'round';
    drawCtx.lineJoin  = 'round';
    drawCtx.strokeStyle = highlight ? '#f39c12' : stroke.color;
    drawCtx.lineWidth   = highlight ? stroke.size + 6 : stroke.size;
    if (highlight) drawCtx.globalAlpha = 0.5;
    drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
    stroke.points.forEach(p => drawCtx.lineTo(p.x, p.y));
    drawCtx.stroke();
    drawCtx.restore();
    if (highlight) {
        // Re-dessiner le trait par-dessus en couleur originale
        drawCtx.save();
        drawCtx.beginPath();
        drawCtx.lineCap  = 'round';
        drawCtx.lineJoin = 'round';
        drawCtx.strokeStyle = stroke.color;
        drawCtx.lineWidth   = stroke.size;
        drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        stroke.points.forEach(p => drawCtx.lineTo(p.x, p.y));
        drawCtx.stroke();
        drawCtx.restore();
    }
}

function toggleDrawToolbar() {
    const toolbar = document.getElementById('draw-toolbar');
    const isVisible = toolbar.style.display === 'flex';
    if (isVisible) { stopDrawing(); return; }
    stopSelectMode();
    toolbar.style.display = 'flex';
    initCanvas();
    enableDrawing();
}

function enableDrawing() {
    isDrawMode = true;
    drawCanvas.classList.remove('inactive');
    document.getElementById('draw-btn').style.background = '#c0136f';
    document.getElementById('draw-btn').textContent = '‚úèÔ∏è En cours‚Ä¶';
}

function stopDrawing() {
    isDrawMode = false;
    if (drawCanvas) drawCanvas.classList.add('inactive');
    document.getElementById('draw-toolbar').style.display = 'none';
    document.getElementById('draw-btn').style.background = '#e84393';
    document.getElementById('draw-btn').textContent = '‚úèÔ∏è Dessin';
}

function clearCanvas() {
    strokes = [];
    selectedStrokes = [];
    redrawStrokes();
}

const _origHandleWindowResize = handleWindowResize;
handleWindowResize = function() {
    _origHandleWindowResize();
    resizeCanvas();
};

// =========================================================================
// MODE S√âLECTION
// =========================================================================

let isSelectMode     = false;
let isSelectObj      = false; // mode "s√©lectionner objet"
let isSelectZone     = false; // mode "s√©lectionner zone"

let selectedWidgets  = [];    // widgets s√©lectionn√©s
let selectedStrokes  = [];    // traits s√©lectionn√©s

// Rectangle de s√©lection zone
let isSelectingRect  = false;
let selectStartX     = 0, selectStartY = 0;
let selectionRect    = null;

// D√©placement
let isMoveMode       = false;
let moveStartX       = 0, moveStartY = 0;
let widgetMoveOrigins = []; // { widget, origLeft, origTop }
let strokeMoveOrigins = []; // { stroke, origPoints }

// Rotation
let isRotateMode     = false;
let rotateCenterX    = 0, rotateCenterY = 0;
let rotateStartAngle = 0;
let currentRotation  = 0;

function initSelectionRect() {
    if (selectionRect) return;
    selectionRect = document.createElement('div');
    selectionRect.id = 'selection-rect';
    board.appendChild(selectionRect);
}

// ‚îÄ‚îÄ OUVRIR / FERMER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function toggleSelectToolbar() {
    const toolbar = document.getElementById('select-toolbar');
    if (toolbar.style.display === 'flex') { stopSelectMode(); return; }
    stopDrawing();
    toolbar.style.display = 'flex';
    isSelectMode = true;
    initCanvas();
    initSelectionRect();
    document.getElementById('select-btn').style.background = '#c87000';
    document.getElementById('select-btn').textContent = 'üî≤ S√©lection ON';
    // D√©sactiver drag natif des widgets
    document.querySelectorAll('.drag-handle').forEach(h => h.style.pointerEvents = 'none');
}

function stopSelectMode() {
    isSelectMode = isSelectObj = isSelectZone = false;
    isMoveMode   = false;
    isRotateMode = false;
    document.getElementById('select-toolbar').style.display = 'none';
    document.getElementById('select-btn').style.background = '#f39c12';
    document.getElementById('select-btn').textContent = 'üî≤ S√©lectionner';
    clearSelection();
    document.querySelectorAll('.drag-handle').forEach(h => h.style.pointerEvents = 'auto');
    // Remettre le curseur du canvas
    if (drawCanvas) { drawCanvas.classList.add('inactive'); drawCanvas.style.cursor = ''; }
}

function clearSelection() {
    selectedWidgets.forEach(w => w.classList.remove('selected'));
    selectedWidgets = [];
    selectedStrokes = [];
    redrawStrokes();
    if (selectionRect) selectionRect.style.display = 'none';
    updateSelectionBtns();
}

// ‚îÄ‚îÄ BOUTONS OBJET / ZONE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function activateSelectObj() {
    isSelectObj  = true;
    isSelectZone = false;
    clearSelection();
    // Activer le canvas pour d√©tecter les clics sur les traits
    if (drawCanvas) {
        drawCanvas.classList.remove('inactive');
        drawCanvas.style.cursor = 'crosshair';
    }
    // Listeners
    board.addEventListener('mousedown', onObjMouseDown);
    board.removeEventListener('mousedown', onZoneMouseDown);
    highlightBtn('obj-btn', true);
    highlightBtn('zone-btn', false);
}

function activateSelectZone() {
    isSelectZone = true;
    isSelectObj  = false;
    clearSelection();
    if (drawCanvas) {
        drawCanvas.classList.remove('inactive');
        drawCanvas.style.cursor = 'crosshair';
    }
    board.addEventListener('mousedown', onZoneMouseDown);
    board.removeEventListener('mousedown', onObjMouseDown);
    highlightBtn('zone-btn', true);
    highlightBtn('obj-btn', false);
}

function highlightBtn(id, active) {
    const btn = document.getElementById(id);
    if (!btn) return;
    btn.style.outline = active ? '2px solid #fff' : 'none';
    btn.style.opacity = active ? '1' : '0.7';
}

// ‚îÄ‚îÄ S√âLECTION OBJET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function onObjMouseDown(e) {
    if (!isSelectObj) return;

    // Widget cliqu√© ?
    const widget = e.target.closest('.widget');
    if (widget) {
        e.stopPropagation();
        clearSelection();
        selectedWidgets = [widget];
        widget.classList.add('selected');
        updateSelectionBtns();
        return;
    }

    // Trait cliqu√© ?
    const pos    = getCanvasPos(e);
    const stroke = findStrokeAt(pos.x, pos.y);
    if (stroke) {
        clearSelection();
        selectedStrokes = [stroke];
        redrawStrokes();
        updateSelectionBtns();
    } else {
        clearSelection();
    }
}

function getCanvasPos(e) {
    const rect = board.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
}

// D√©tecte si un point (x,y) est proche d'un trait (tol√©rance = size/2 + 5px)
function findStrokeAt(x, y) {
    // Parcourir les traits en sens inverse (le dernier dessin√© en priorit√©)
    for (let i = strokes.length - 1; i >= 0; i--) {
        const stroke = strokes[i];
        const tol    = stroke.size / 2 + 5;
        for (let j = 1; j < stroke.points.length; j++) {
            const a = stroke.points[j - 1];
            const b = stroke.points[j];
            if (distToSegment(x, y, a, b) <= tol) return stroke;
        }
    }
    return null;
}

function distToSegment(px, py, a, b) {
    const dx = b.x - a.x, dy = b.y - a.y;
    const lenSq = dx * dx + dy * dy;
    if (lenSq === 0) return Math.hypot(px - a.x, py - a.y);
    let t = ((px - a.x) * dx + (py - a.y) * dy) / lenSq;
    t = Math.max(0, Math.min(1, t));
    return Math.hypot(px - (a.x + t * dx), py - (a.y + t * dy));
}

// ‚îÄ‚îÄ S√âLECTION ZONE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function onZoneMouseDown(e) {
    if (!isSelectZone) return;
    if (e.target.closest('.widget')) return; // ne pas interf√©rer avec les widgets
    clearSelection();
    isSelectingRect = true;
    const pos = getCanvasPos(e);
    selectStartX = pos.x; selectStartY = pos.y;
    selectionRect.style.cssText = `display:block; left:${pos.x}px; top:${pos.y}px; width:0; height:0;`;
    board.addEventListener('mousemove', onZoneMouseMove);
    board.addEventListener('mouseup',   onZoneMouseUp);
}

function onZoneMouseMove(e) {
    if (!isSelectingRect) return;
    const pos = getCanvasPos(e);
    const x = Math.min(pos.x, selectStartX);
    const y = Math.min(pos.y, selectStartY);
    const w = Math.abs(pos.x - selectStartX);
    const h = Math.abs(pos.y - selectStartY);
    selectionRect.style.left   = x + 'px';
    selectionRect.style.top    = y + 'px';
    selectionRect.style.width  = w + 'px';
    selectionRect.style.height = h + 'px';
}

function onZoneMouseUp(e) {
    if (!isSelectingRect) return;
    isSelectingRect = false;
    board.removeEventListener('mousemove', onZoneMouseMove);
    board.removeEventListener('mouseup',   onZoneMouseUp);

    const pos = getCanvasPos(e);
    const rx = Math.min(pos.x, selectStartX);
    const ry = Math.min(pos.y, selectStartY);
    const rw = Math.abs(pos.x - selectStartX);
    const rh = Math.abs(pos.y - selectStartY);
    if (rw < 5 && rh < 5) { clearSelection(); return; }

    // Widgets dans la zone
    document.querySelectorAll('.widget').forEach(w => {
        const wr = w.getBoundingClientRect();
        const br = board.getBoundingClientRect();
        const wl = wr.left - br.left, wt = wr.top - br.top;
        if (wl < rx + rw && wl + wr.width > rx && wt < ry + rh && wt + wr.height > ry) {
            selectedWidgets.push(w);
            w.classList.add('selected');
        }
    });

    // Traits dans la zone
    strokes.forEach(stroke => {
        const inZone = stroke.points.some(p => p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh);
        if (inZone) selectedStrokes.push(stroke);
    });

    redrawStrokes();
    updateSelectionBtns();
    if (selectionRect) selectionRect.style.display = 'none';
}

// ‚îÄ‚îÄ D√âPLACEMENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function toggleMoveMode() {
    const has = selectedWidgets.length > 0 || selectedStrokes.length > 0;
    if (!has) return;
    isMoveMode   = !isMoveMode;
    isRotateMode = false;
    const btn = document.getElementById('move-btn');
    btn.style.background = isMoveMode ? '#0056d6' : '#2B7FFF';
    btn.textContent      = isMoveMode ? '‚ú• D√©pl. actif' : '‚ú• D√©placer';
    document.getElementById('rotate-btn').style.background = '#8E51FF';
    document.getElementById('rotate-btn').textContent      = 'üîÑ Rotation';
    document.getElementById('rotate-label').style.display  = 'none';

    if (isMoveMode) {
        board.addEventListener('mousedown', onMoveStart);
    } else {
        board.removeEventListener('mousedown', onMoveStart);
    }
}

function onMoveStart(e) {
    if (!isMoveMode) return;
    const pos = getCanvasPos(e);
    moveStartX = pos.x; moveStartY = pos.y;
    // M√©moriser les positions d'origine
    widgetMoveOrigins = selectedWidgets.map(w => ({ widget: w, origLeft: w.offsetLeft, origTop: w.offsetTop }));
    strokeMoveOrigins = selectedStrokes.map(s => ({ stroke: s, origPoints: s.points.map(p => ({ ...p })) }));
    board.addEventListener('mousemove', onMoveMove);
    board.addEventListener('mouseup',   onMoveEnd);
}

function onMoveMove(e) {
    const pos = getCanvasPos(e);
    const dx  = pos.x - moveStartX;
    const dy  = pos.y - moveStartY;
    widgetMoveOrigins.forEach(({ widget, origLeft, origTop }) => {
        widget.style.left = (origLeft + dx) + 'px';
        widget.style.top  = (origTop  + dy) + 'px';
    });
    strokeMoveOrigins.forEach(({ stroke, origPoints }) => {
        stroke.points = origPoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
    });
    redrawStrokes();
}

function onMoveEnd() {
    board.removeEventListener('mousemove', onMoveMove);
    board.removeEventListener('mouseup',   onMoveEnd);
    // Mettre √† jour les dataset % des widgets
    const curW  = window.innerWidth;
    const curVH = virtualH(curW);
    selectedWidgets.forEach(w => {
        w.dataset.leftPercent = (w.offsetLeft / curW)  * 100;
        w.dataset.topPercent  = (w.offsetTop  / curVH) * 100;
    });
    saveBoard();
}

// ‚îÄ‚îÄ ROTATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function toggleRotateMode() {
    const has = selectedWidgets.length > 0 || selectedStrokes.length > 0;
    if (!has) return;
    isRotateMode = !isRotateMode;
    isMoveMode   = false;
    const btn = document.getElementById('rotate-btn');
    const lbl = document.getElementById('rotate-label');
    btn.style.background = isRotateMode ? '#5a1fb8' : '#8E51FF';
    btn.textContent      = isRotateMode ? 'üîÑ Rot. active' : 'üîÑ Rotation';
    lbl.style.display    = isRotateMode ? 'inline' : 'none';
    document.getElementById('move-btn').style.background = '#2B7FFF';
    document.getElementById('move-btn').textContent      = '‚ú• D√©placer';

    if (isRotateMode) {
        board.addEventListener('mousedown', onRotateStart);
    } else {
        board.removeEventListener('mousedown', onRotateStart);
    }
}

function getSelectionCenter() {
    // Centre de la s√©lection (bounding box de tous les √©l√©ments)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const br = board.getBoundingClientRect();
    selectedWidgets.forEach(w => {
        const r = w.getBoundingClientRect();
        minX = Math.min(minX, r.left - br.left);
        minY = Math.min(minY, r.top  - br.top);
        maxX = Math.max(maxX, r.right  - br.left);
        maxY = Math.max(maxY, r.bottom - br.top);
    });
    selectedStrokes.forEach(s => {
        s.points.forEach(p => {
            minX = Math.min(minX, p.x); minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y);
        });
    });
    return { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
}

let rotateOrigWidgetTransforms = [];
let rotateOrigStrokePoints     = [];

function onRotateStart(e) {
    if (!isRotateMode) return;
    const center = getSelectionCenter();
    rotateCenterX    = center.x;
    rotateCenterY    = center.y;
    rotateStartAngle = Math.atan2(e.clientY - board.getBoundingClientRect().top - rotateCenterY,
                                  e.clientX - board.getBoundingClientRect().left - rotateCenterX);
    currentRotation  = 0;
    // Sauvegarder √©tats d'origine
    rotateOrigWidgetTransforms = selectedWidgets.map(w => ({
        widget: w,
        origLeft: w.offsetLeft, origTop: w.offsetTop,
        origRot: getCurrentRotation(w)
    }));
    rotateOrigStrokePoints = selectedStrokes.map(s => ({
        stroke: s,
        origPoints: s.points.map(p => ({ ...p }))
    }));
    board.addEventListener('mousemove', onRotateMove);
    board.addEventListener('mouseup',   onRotateEnd);
}

function onRotateMove(e) {
    const br    = board.getBoundingClientRect();
    const angle = Math.atan2(e.clientY - br.top  - rotateCenterY,
                             e.clientX - br.left - rotateCenterX);
    const delta = (angle - rotateStartAngle) * (180 / Math.PI);
    document.getElementById('rotate-label').textContent = Math.round(delta) + '¬∞';

    // Rotation des widgets autour du centre de s√©lection
    rotateOrigWidgetTransforms.forEach(({ widget, origLeft, origTop, origRot }) => {
        const cx = origLeft + widget.offsetWidth  / 2 - rotateCenterX;
        const cy = origTop  + widget.offsetHeight / 2 - rotateCenterY;
        const rad = delta * Math.PI / 180;
        const nx  = cx * Math.cos(rad) - cy * Math.sin(rad);
        const ny  = cx * Math.sin(rad) + cy * Math.cos(rad);
        widget.style.left      = (rotateCenterX + nx - widget.offsetWidth  / 2) + 'px';
        widget.style.top       = (rotateCenterY + ny - widget.offsetHeight / 2) + 'px';
        widget.style.transform = `rotate(${origRot + delta}deg)`;
    });

    // Rotation des traits autour du centre de s√©lection
    rotateOrigStrokePoints.forEach(({ stroke, origPoints }) => {
        const rad = delta * Math.PI / 180;
        stroke.points = origPoints.map(p => {
            const dx = p.x - rotateCenterX;
            const dy = p.y - rotateCenterY;
            return {
                x: rotateCenterX + dx * Math.cos(rad) - dy * Math.sin(rad),
                y: rotateCenterY + dx * Math.sin(rad) + dy * Math.cos(rad)
            };
        });
    });
    redrawStrokes();
}

function onRotateEnd() {
    board.removeEventListener('mousemove', onRotateMove);
    board.removeEventListener('mouseup',   onRotateEnd);
    saveBoard();
}

function getCurrentRotation(widget) {
    const transform = widget.style.transform;
    if (!transform) return 0;
    const match = transform.match(/rotate\(([-\d.]+)deg\)/);
    return match ? parseFloat(match[1]) : 0;
}

// ‚îÄ‚îÄ SUPPRESSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function deleteSelected() {
    if (!selectedWidgets.length && !selectedStrokes.length) return;
    selectedWidgets.forEach(w => { w.classList.remove('selected'); w.remove(); });
    selectedWidgets = [];
    strokes = strokes.filter(s => !selectedStrokes.includes(s));
    selectedStrokes = [];
    redrawStrokes();
    if (selectionRect) selectionRect.style.display = 'none';
    updateSelectionBtns();
    saveBoard();
}

// ‚îÄ‚îÄ √âTAT DES BOUTONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function updateSelectionBtns() {
    const has = selectedWidgets.length > 0 || selectedStrokes.length > 0;
    ['delete-btn', 'move-btn', 'rotate-btn'].forEach(id => {
        const btn = document.getElementById(id);
        if (!btn) return;
        btn.style.opacity = has ? '1' : '0.4';
        btn.style.cursor  = has ? 'pointer' : 'not-allowed';
    });
}

    // =========================================================================
    // FORMATAGE TEXTE
    // =========================================================================

    function format(cmd, val = null) {
        document.execCommand(cmd, false, val);
        saveBoard();
    }

    function formatFontSize(size) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0) return;
        document.execCommand("fontSize", false, "7");
        const fontElements = document.getElementsByTagName("font");
        for (let i = 0; i < fontElements.length; i++) {
            if (fontElements[i].size === "7") {
                fontElements[i].removeAttribute("size");
                fontElements[i].style.fontSize = size + "px";
            }
        }
        saveBoard();
    }

    function formatFontFamily(font) {
        document.execCommand('fontName', false, font);
        const selection = window.getSelection();
        if (selection.anchorNode) selection.anchorNode.parentElement.style.fontFamily = font;
        saveBoard();
    }

    function changeWidgetBg(input, color) {
        const widget = input.closest('.widget');
        applyTransparency(widget, false);
        widget.style.background = color;
        widget.dataset.bgColor  = color;
        saveBoard();
    }

    function toggleTransparency(btn) {
        const widget  = btn.closest('.widget');
        const isTrans = widget.dataset.transparent === "true";
        applyTransparency(widget, !isTrans);
        saveBoard();
    }

    function applyTransparency(widget, isTransparent) {
        widget.dataset.transparent = isTransparent;
        if (isTransparent) {
            widget.style.background = 'transparent';
            widget.style.boxShadow  = 'none';
            widget.style.border     = 'none';
        } else {
            const bgColor = widget.dataset.bgColor || '#ffffff';
            widget.style.background = bgColor;
            widget.style.boxShadow  = '';
            widget.style.border     = '';
        }
    }

    // =========================================================================
    // PLEIN √âCRAN, YOUTUBE, IFRAME
    // =========================================================================

    function toggleFullScreen(element) {
        if (!document.fullscreenElement) {
            element.requestFullscreen().catch(err => console.log(err));
        } else {
            document.exitFullscreen();
        }
    }

    function loadIframe(input) {
        const iframe = input.closest('.editor-container').querySelector('iframe');
        let url = input.value.trim();
        if (url && !url.startsWith('http')) url = 'https://' + url;
        iframe.src = url;
        saveBoard();
    }

    function loadYoutube(input) {
        const container = input.closest('.editor-container');
        const iframe    = container.querySelector('iframe');
        let url         = input.value.trim();
        let videoId     = null;

        const regexStd   = /(?:v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const regexShort = /shorts\/([a-zA-Z0-9_-]{11})/;
        let match        = url.match(regexStd) || url.match(regexShort);
        if (match) videoId = match[1];

        if (videoId) {
            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
        } else {
            iframe.src = url;
        }
        saveBoard();
    }

    function toggleYoutubeView(btn, display) {
        const container = btn.closest('.editor-container');
        const iframe    = container.querySelector('iframe');
        iframe.style.display = display;
        if (display === 'none') {
            container.style.height = '50px';
        } else {
            container.style.height = '';
        }
        saveBoard();
    }

    // =========================================================================
    // AGENDA
    // =========================================================================

    let dragSrcRow = null;

    function handleRowDragStart(e) {
        dragSrcRow = this;
        this.classList.add('dragging');
    }

    function handleRowDragOver(e) {
        e.preventDefault();
        if (!dragSrcRow || dragSrcRow === this) return;
        const list   = this.parentNode;
        const items  = [...list.querySelectorAll('.agenda-item')];
        const srcIdx = items.indexOf(dragSrcRow);
        const dstIdx = items.indexOf(this);
        if (srcIdx < dstIdx) list.insertBefore(dragSrcRow, this.nextSibling);
        else                  list.insertBefore(dragSrcRow, this);
    }

    function handleRowDragEnd() {
        this.classList.remove('dragging');
        dragSrcRow = null;
        saveBoard();
    }

    function addAgendaLine(btn) {
        const list = btn.closest('.agenda-container').querySelector('.agenda-list');
        const item = document.createElement('div');
        item.className  = 'agenda-item';
        item.draggable  = true;
        item.innerHTML  = `
            <span class="agenda-row-handle">‚ãÆ‚ãÆ</span>
            <span class="agenda-time" contenteditable="true">--:--</span>
            <div class="agenda-text" contenteditable="true">Nouvelle ligne</div>
            <span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer la ligne">√ó</span>`;
        list.appendChild(item);
        attachAgendaItemEvents(item);
        saveBoard();
    }

    function deleteAgendaLine(btn) {
        btn.closest('.agenda-item').remove();
        saveBoard();
    }

    // =========================================================================
    // FOND D'√âCRAN
    // =========================================================================

    function applyBackground(value) {
        if (value === 'none' || !value) {
            board.style.background    = '';
            board.style.backgroundColor = '#eef2f5';
        } else if (value.startsWith('#') || value.startsWith('rgb')) {
            board.style.background    = '';
            board.style.backgroundColor = value;
        } else {
            board.style.background = value;
        }
    }

    function saveBg(value) {
        localStorage.setItem('boardBackground', value);
    }

    function handleBgUpload(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            const value = `url(${e.target.result})`;
            applyBackground(value);
            saveBg(value);
        };
        reader.readAsDataURL(file);
    }

    function toggleSubMenu(event) {
        event.stopPropagation();
        document.getElementById('bg-submenu').classList.toggle('active');
    }

    // =========================================================================
    // MENU
    // =========================================================================

    function toggleMenu() {
        document.getElementById('tools-menu').classList.toggle('active');
        document.getElementById('bg-submenu').classList.remove('active');
    }

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#toolbar-container')) {
            document.getElementById('tools-menu').classList.remove('active');
            document.getElementById('bg-submenu').classList.remove('active');
        }
    });
	
	let currentActiveWidget = null;

	function toggleGlobalToolbar() {
		const toolbar = document.getElementById('global-toolbar');
		toolbar.style.display = toolbar.style.display === 'flex' ? 'none' : 'flex';
		// ‚Üê ne jamais toucher √† la visibilit√© du bouton
	}

	function closeGlobalToolbar() {
		document.getElementById('global-toolbar').style.display = 'none';
		currentActiveWidget = null;
	}

	function formatGlobal(cmd, val = null) {
		if (!currentActiveWidget) return;
		if (savedSelection) {
			const selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange(savedSelection);
			savedSelection = null;
		}
		document.execCommand(cmd, false, val);
		saveBoard();
	}

	function formatFontSizeGlobal(size) {
		if (!currentActiveWidget) return;
		const editor = currentActiveWidget.querySelector('.editor-content');
		if (!editor) return;

		if (savedSelection) {
			const selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange(savedSelection);
		}

		const selection = window.getSelection();
		if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
			const range = selection.getRangeAt(0);
			const span = document.createElement('span');
			span.style.fontSize = size + 'px';
			// ‚Üê PLUS de data-manual-font-size
			try {
				range.surroundContents(span);
			} catch(e) {
				const fragment = range.extractContents();
				span.appendChild(fragment);
				range.insertNode(span);
			}
			const newRange = document.createRange();
			newRange.setStartAfter(span);
			newRange.collapse(true);
			selection.removeAllRanges();
			selection.addRange(newRange);
		} else {
			editor.style.fontSize = size + 'px';
			// ‚Üê PLUS de data-manual-font-size
			editor.querySelectorAll('*').forEach(el => {
				if (el.style.fontSize) {
					el.style.fontSize = size + 'px';
					// ‚Üê PLUS de data-manual-font-size
				}
			});
		}

		savedSelection = null;
		saveBoard();
	}

	function saveCurrentSelection() {
		const selection = window.getSelection();
		if (selection && selection.rangeCount > 0) {
			return selection.getRangeAt(0).cloneRange();
		}
		return null;
	}
	
	function formatFontFamilyGlobal(font) {
		if (!currentActiveWidget) return;
		document.execCommand('fontName', false, font);
		const selection = window.getSelection();
		if (selection.anchorNode) selection.anchorNode.parentElement.style.fontFamily = font;
		saveBoard();
	}

	function changeWidgetBgGlobal(input, color) {
		if (!currentActiveWidget) return;
		const container = currentActiveWidget.querySelector('.editor-container');
		if (!container) return;
		applyTransparency(currentActiveWidget, false);
		container.style.background = color;
		currentActiveWidget.dataset.bgColor = color;
		saveBoard();
	}

	function toggleTransparencyGlobal() {
		if (!currentActiveWidget) return;
		const widget  = currentActiveWidget;
		const isTrans = widget.dataset.transparent === "true";
		applyTransparency(widget, !isTrans);
		saveBoard();
	}

	function applyTextColor(color) {
		if (!currentActiveWidget) return;
		if (savedSelection) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(savedSelection);
			savedSelection = null;
		}
		document.execCommand('foreColor', false, color);
		saveBoard();
	}

	function applyHighlightColor(color) {
		if (!currentActiveWidget) return;
		if (savedSelection) {
			const sel = window.getSelection();
			sel.removeAllRanges();
			sel.addRange(savedSelection);
			savedSelection = null;
		}
		document.execCommand('backColor', false, color);
		saveBoard();
	}

	function applyTransparency(widget, isTransparent) {
		const container = widget.querySelector('.editor-container');
		widget.dataset.transparent = isTransparent;
		if (isTransparent) {
			widget.style.background  = 'transparent';
			widget.style.boxShadow   = 'none';
			widget.style.border      = 'none';
			if (container) container.style.background = 'transparent';
		} else {
			const bgColor = widget.dataset.bgColor || '#ffffff';
			widget.style.background = '';
			widget.style.boxShadow  = '';
			widget.style.border     = '';
			if (container) container.style.background = bgColor;
		}
	}

	function syncFontSizeGlobal() {
		if (!currentActiveWidget) return;
		const editor = currentActiveWidget.querySelector('.editor-content');
		if (!editor) return;

		const selection = window.getSelection();
		let size = 40;

		if (selection.rangeCount > 0) {
			const node = selection.anchorNode.parentElement;
			if (node && node.style.fontSize) {
				size = parseInt(node.style.fontSize) || 40;
			}
		} else {
			size = parseInt(window.getComputedStyle(editor).fontSize) || 40;
		}

		const sizeInput = document.querySelector('#global-toolbar input[type="number"]');
		if (sizeInput) sizeInput.value = size;
	}

	function validateAndApplyFontSize(input) {
		let value = parseInt(input.value);
		if (isNaN(value) || value < 8) value = 8;
		if (value > 100) value = 100;
		input.value = value;

		formatFontSizeGlobal(value);
	}

	function applyFontSizeFromInput(input) {
		const size = parseInt(input.value);
		if (isNaN(size) || size < 8) {
			input.value = 8;
			return;
		}
		if (size > 100) {
			input.value = 100;
			return;
		}

		formatFontSizeGlobal(size);
	}

	function applyFontSizeOnBlur(input) {
		const size = parseInt(input.value);
		if (isNaN(size) || size < 8) {
			input.value = 8;
			return;
		}
		if (size > 100) {
			input.value = 100;
			return;
		}

		formatFontSizeGlobal(size);

		// Restaurer la s√©lection sauvegard√©e
		if (savedSelection) {
			const selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange(savedSelection);
			savedSelection = null; // Nettoyer
			console.log('S√©lection restaur√©e');
		}
	}

	// √âcouteur sur les widgets texte/devoirs
	document.addEventListener('click', (e) => {
		const widget = e.target.closest('.widget');
		const isTextOrHomework = widget && (widget.dataset.type === 'text' || widget.dataset.type === 'homework');

		if (isTextOrHomework) {
			currentActiveWidget = widget;
			document.getElementById('global-toolbar').style.display = 'flex';
			syncFontSizeGlobal();
			return;
		}

		if (!e.target.closest('#global-toolbar') && !e.target.closest('#toolbar-toggle-btn') && !isTextOrHomework) {
			if (currentActiveWidget) {
				currentActiveWidget = null;
				document.getElementById('global-toolbar').style.display = 'none';
			}
		}
	});

    // =========================================================================
	// ANNULER REFAIRE
	// =========================================================================

	let isUndoing = false;
	let lastSavedConfig = null; // Pour √©viter les doublons

	function takeSnapshot() {
		if (isInitialLoading || isUndoing) return;
		const currentConfig = localStorage.getItem('profBoardConfig') || null;
		if (history.length > 0 && history[history.length - 1].config === currentConfig) return;
		history.push({
			config:     currentConfig,
			background: localStorage.getItem('boardBackground') || 'none'
		});
		redoHistory = []; // ‚Üê toute nouvelle action efface le futur
		updateUndoRedoBtns();
	}

	function undoAction() {
		if (history.length === 0) return;
		isUndoing = true;
		const snap = history.pop();
		if (snap.config) localStorage.setItem('profBoardConfig', snap.config);
		if (snap.background) {
			localStorage.setItem('boardBackground', snap.background);
			applyBackground(snap.background);
		}
		document.querySelectorAll('.widget').forEach(w => w.remove());
		_lastW = window.innerWidth;
		loadBoard();
		isUndoing = false;
	}
	
	let redoHistory = [];

	function undoAction() {
		if (history.length === 0) return;
		isUndoing = true;

		// Sauvegarder l'√©tat courant dans redoHistory avant de reculer
		redoHistory.push({
			config:     localStorage.getItem('profBoardConfig') || null,
			background: localStorage.getItem('boardBackground') || 'none'
		});

		const snap = history.pop();
		if (snap.config) localStorage.setItem('profBoardConfig', snap.config);
		if (snap.background) {
			localStorage.setItem('boardBackground', snap.background);
			applyBackground(snap.background);
		}
		document.querySelectorAll('.widget').forEach(w => w.remove());
		_lastW = window.innerWidth;
		loadBoard();
		isUndoing = false;
		updateUndoRedoBtns();
	}

	function redoAction() {
		if (redoHistory.length === 0) return;
		isUndoing = true;

		// Sauvegarder l'√©tat courant dans history avant de refaire
		history.push({
			config:     localStorage.getItem('profBoardConfig') || null,
			background: localStorage.getItem('boardBackground') || 'none'
		});

		const snap = redoHistory.pop();
		if (snap.config) localStorage.setItem('profBoardConfig', snap.config);
		if (snap.background) {
			localStorage.setItem('boardBackground', snap.background);
			applyBackground(snap.background);
		}
		document.querySelectorAll('.widget').forEach(w => w.remove());
		_lastW = window.innerWidth;
		loadBoard();
		isUndoing = false;
		updateUndoRedoBtns();
	}

	function updateUndoRedoBtns() {
		const undoBtn = document.getElementById('undo-btn');
		const redoBtn = document.getElementById('redo-btn');
		if (undoBtn) {
			undoBtn.style.opacity = history.length === 0 ? '0.4' : '1';
			undoBtn.style.cursor  = history.length === 0 ? 'not-allowed' : 'pointer';
		}
		if (redoBtn) {
			redoBtn.style.opacity = redoHistory.length === 0 ? '0.4' : '1';
			redoBtn.style.cursor  = redoHistory.length === 0 ? 'not-allowed' : 'pointer';
		}
	}

    // =========================================================================
    // MISE √Ä JOUR DATE/HEURE (widgets Date et Heure)
    // =========================================================================

    function updateDateTime() {
        const now = new Date();
        const days   = ['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'];
        const months = ['janvier','f√©vrier','mars','avril','mai','juin','juillet','ao√ªt','septembre','octobre','novembre','d√©cembre'];

        document.querySelectorAll('.calendar-day-name').forEach(el   => el.textContent = days[now.getDay()]);
        document.querySelectorAll('.calendar-day-number').forEach(el => el.textContent = now.getDate());
        document.querySelectorAll('.calendar-month').forEach(el      => el.textContent = months[now.getMonth()]);

        const hh = String(now.getHours()).padStart(2,'0');
        const mm = String(now.getMinutes()).padStart(2,'0');
        const ss = String(now.getSeconds()).padStart(2,'0');
        document.querySelectorAll('.clock-hm').forEach(el      => el.textContent = `${hh}:${mm}`);
        document.querySelectorAll('.clock-seconds').forEach(el => el.textContent = ss);
    }

</script>

	
	
</body>
</html>
