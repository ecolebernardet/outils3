<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Bureau du Prof</title>
<style>
        :root {
            --bg-color: #eef2f5;
            --widget-bg: #ffffff;
            --primary-color: #4a90e2;
            --text-color: #333;
            --shadow: 0 8px 24px rgba(149, 157, 165, 0.2);
            --border-radius: 18px;
        }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background-color: #1a1a2e; font-family: 'Segoe UI', system-ui, sans-serif; overflow: hidden; }
        #board { position: absolute; background-color: var(--bg-color); z-index: 0; transition: background 0.3s ease; overflow: hidden; }

        /* --- WIDGETS --- */
        .widget { position: absolute; background: var(--widget-bg); border-radius: var(--border-radius); box-shadow: var(--shadow); display: flex; flex-direction: column; z-index: 1; border: 2px solid transparent; height: auto; outline: none; transition: border-color 0.2s, box-shadow 0.2s; box-sizing: border-box; }
        .widget:focus-within { border-color: var(--primary-color); box-shadow: 0 12px 30px rgba(74, 144, 226, 0.3); }
        .widget[data-type="homework"]:focus-within { border-color: #ff4757; }
        .widget[data-type="iframe"]:focus-within { border-color: #2bcbba; }
        .widget[data-transparent="true"] { border: none !important; box-shadow: none !important; background: transparent !important; }
        .widget[data-transparent="true"]:hover, .widget[data-transparent="true"]:focus-within { background: rgba(74, 144, 226, 0.05) !important; }
        .widget[data-transparent="true"] .editor-container, .widget[data-transparent="true"] .editor-content { border: none !important; background: transparent !important; }

        /* --- CONTR√îLES NATIFS DES WIDGETS --- */
        .widget-header { display: none !important; }
        .drag-handle, .widget-close-handle, .widget-pin-handle, .widget-rotate-handle, .widget-menu-handle, .widget-back-handle {
            position: absolute; width: 26px; height: 26px; background: #f8f9fa; border-radius: 6px;
            display: flex; align-items: center; justify-content: center; z-index: 100;
            opacity: 0; transition: opacity 0.2s; border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); pointer-events: none;
        }
        .drag-handle          { left: -13px; top: 50%; transform: translateY(-50%); cursor: move; font-size: 14px; color: #666; }
        .widget-rotate-handle { right: -13px; top: 50%; transform: translateY(-50%); cursor: grab; font-size: 14px; color: #8E51FF; }
        .widget-rotate-handle:active { cursor: grabbing; }
        #rotation-indicator {
            position: fixed; background: rgba(30,30,30,0.82); color: #fff;
            font-size: 12px; font-family: 'Courier New', monospace; font-weight: 700;
            padding: 3px 9px; border-radius: 6px; pointer-events: none;
            z-index: 99999; display: none; white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transform: translate(14px, -50%);
        }
        #rotation-indicator .rot-reset-hint {
            font-size: 10px; color: #aaa; margin-left: 6px;
        }
        .widget-close-handle  { top: 5px; right: 5px; cursor: pointer; font-size: 14px; color: #ff5f56; }
        .widget-pin-handle    { top: -13px; left: calc(50% - 16px); transform: translateX(-50%); cursor: pointer; font-size: 13px; color: #f39c12; }
        .widget-back-handle   { top: -13px; left: calc(50% + 16px); transform: translateX(-50%); cursor: pointer; font-size: 13px; color: #888; }
        .widget-menu-handle   { bottom: -13px; left: 50%; transform: translateX(-50%); top: auto; cursor: pointer; font-size: 13px; color: #555; }
        .widget:focus-within .drag-handle,
        .widget:focus-within .widget-close-handle,
        .widget:focus-within .widget-pin-handle,
        .widget:focus-within .widget-back-handle,
        .widget:focus-within .widget-rotate-handle,
        .widget:focus-within .widget-menu-handle { opacity: 1; pointer-events: auto; }
        .shape-widget:focus-within .drag-handle,
        .shape-widget:focus-within .widget-close-handle,
        .shape-widget:focus-within .widget-pin-handle,
        .shape-widget:focus-within .widget-back-handle,
        .shape-widget:focus-within .widget-rotate-handle,
        .shape-widget:focus-within .widget-menu-handle { opacity: 1; pointer-events: auto; }
        /* En multi-s√©lection, forcer le masquage des poign√©es malgr√© focus-within */
        #board.multi-select .widget.selected .drag-handle,
        #board.multi-select .widget.selected .widget-close-handle,
        #board.multi-select .widget.selected .widget-pin-handle,
        #board.multi-select .widget.selected .widget-back-handle,
        #board.multi-select .widget.selected .widget-rotate-handle,
        #board.multi-select .widget.selected .widget-menu-handle,
        #board.multi-select .widget.selected:focus-within .drag-handle,
        #board.multi-select .widget.selected:focus-within .widget-close-handle,
        #board.multi-select .widget.selected:focus-within .widget-pin-handle,
        #board.multi-select .widget.selected:focus-within .widget-back-handle,
        #board.multi-select .widget.selected:focus-within .widget-rotate-handle,
        #board.multi-select .widget.selected:focus-within .widget-menu-handle,
        #board.multi-select .shape-widget.selected .drag-handle,
        #board.multi-select .shape-widget.selected .widget-close-handle,
        #board.multi-select .shape-widget.selected .widget-pin-handle,
        #board.multi-select .shape-widget.selected .widget-back-handle,
        #board.multi-select .shape-widget.selected .widget-rotate-handle,
        #board.multi-select .shape-widget.selected .widget-menu-handle,
        #board.multi-select .shape-widget.selected:focus-within .drag-handle,
        #board.multi-select .shape-widget.selected:focus-within .widget-close-handle,
        #board.multi-select .shape-widget.selected:focus-within .widget-pin-handle,
        #board.multi-select .shape-widget.selected:focus-within .widget-back-handle,
        #board.multi-select .shape-widget.selected:focus-within .widget-rotate-handle,
        #board.multi-select .shape-widget.selected:focus-within .widget-menu-handle { opacity: 0 !important; pointer-events: none !important; }
        .widget-close-handle:hover  { color: #ff5f56; background: white; }
        .drag-handle:hover          { color: var(--primary-color); background: white; }
        .widget-pin-handle:hover    { background: white; }
        .widget-back-handle:hover   { background: white; }
        .widget-rotate-handle:hover { color: #5a1fb8; background: white; }
        .widget-menu-handle:hover   { background: white; }
        .widget.pinned .widget-pin-handle { background: #FFD230; }
        .widget.pinned { border: 2px solid transparent !important; }
        .shape-widget.pinned .widget-pin-handle { background: #FFD230; }

        /* --- MENU CONTEXTUEL --- */
        .widget-ctx-menu {
            position: absolute; bottom: 28px; left: 50%; transform: translateX(-50%); top: auto;
            background: #1F1F21; border: 1px solid #444; border-radius: 10px; padding: 5px 0;
            min-width: 170px; z-index: 200; box-shadow: 0 6px 20px rgba(0,0,0,0.35);
            display: none; flex-direction: column;
        }
        .widget-ctx-menu.open { display: flex; }
        .widget-ctx-menu button {
            background: none; border: none; color: #eee; padding: 7px 14px;
            text-align: left; cursor: pointer; font-size: 13px; display: flex;
            align-items: center; gap: 8px; white-space: nowrap; transition: background 0.12s;
        }
        .widget-ctx-menu button:hover { background: #333; }
        .widget-ctx-menu hr { border: none; border-top: 1px solid #444; margin: 4px 0; }

        /* Curseur crayon pour le mode insertion de texte */
        .cursor-pencil { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' style='fill:black'><text y='20' font-size='20'>‚úèÔ∏è</text></svg>"), auto !important; }
        /* Curseur gomme */
        #draw-canvas.eraser-mode { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32'><rect x='4' y='10' width='24' height='16' rx='3' fill='%23fff' stroke='%23aaa' stroke-width='2'/><rect x='4' y='10' width='12' height='16' rx='3' fill='%23ffcccc'/></svg>"), crosshair !important; }

        /* --- FORMES --- */
        .shape-widget {
            position: absolute; z-index: 1; outline: none;
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            border-radius: 0 !important;
            display: flex; flex-direction: column;
        }
        .shape-widget .drag-handle, .shape-widget .widget-close-handle,
        .shape-widget .widget-pin-handle, .shape-widget .widget-back-handle,
        .shape-widget .widget-rotate-handle, .shape-widget .widget-menu-handle { opacity: 0; pointer-events: none; }
        .shape-svg-wrap { display: flex; align-items: center; justify-content: center; padding: 16px; min-width: 80px; min-height: 80px; cursor: default; }
        .shape-svg-wrap svg { overflow: visible; display: block; pointer-events: none; }
        .shape-resize-handle {
            position: absolute; right: 0; bottom: 0; width: 18px; height: 18px;
            cursor: se-resize; opacity: 0; transition: opacity 0.2s;
            background: linear-gradient(135deg, transparent 50%, #4a90e2 50%);
            border-radius: 0 0 4px 0;
        }
        .shape-widget:focus-within .shape-resize-handle { opacity: 1; }
        .shape-widget[data-group-id]:focus-within .shape-resize-handle { opacity: 0 !important; pointer-events: none !important; }
        /* Bouton verrou proportions sur forme individuelle */
        .resize-lock-btn {
            position: absolute; right: 20px; bottom: 0;
            width: 20px; height: 18px; background: white; border: 1px solid #ccc;
            border-radius: 4px 0 0 0; cursor: pointer; opacity: 0; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; font-size: 11px;
            z-index: 101; user-select: none; pointer-events: none;
            box-shadow: -1px 0 3px rgba(0,0,0,0.1);
        }
        .shape-widget:focus-within .resize-lock-btn { opacity: 1; pointer-events: auto; }
        .shape-widget[data-group-id]:focus-within .resize-lock-btn { opacity: 0 !important; pointer-events: none !important; }
        .resize-lock-btn.locked { background: #4a90e2; color: white; border-color: #357abd; }
        /* Boutons sym√©trie sur forme individuelle */
        .flip-h-btn, .flip-v-btn {
            position: absolute; width: 20px; height: 18px; background: white; border: 1px solid #ccc;
            cursor: pointer; opacity: 0; transition: opacity 0.2s;
            display: flex; align-items: center; justify-content: center; font-size: 11px;
            z-index: 101; user-select: none; pointer-events: none;
            box-shadow: -1px 0 3px rgba(0,0,0,0.1);
        }
        .flip-h-btn { right: 60px; bottom: 0; border-radius: 4px 0 0 0; }
        .flip-v-btn { right: 40px; bottom: 0; border-radius: 0; }
        .shape-widget:focus-within .flip-h-btn,
        .shape-widget:focus-within .flip-v-btn { opacity: 1; pointer-events: auto; }
        .shape-widget[data-group-id]:focus-within .flip-h-btn,
        .shape-widget[data-group-id]:focus-within .flip-v-btn { opacity: 0 !important; pointer-events: none !important; }
        .flip-h-btn:hover, .flip-v-btn:hover, .resize-lock-btn:hover { background: #eef2f5; }
        /* Boutons sym√©trie dans l'overlay groupe */
        #sc-flip-h-btn, #sc-flip-v-btn {
            position: absolute; bottom: 14px;
            width: 24px; height: 24px; background: white; border: 1px solid #ccc;
            border-radius: 5px; cursor: pointer; pointer-events: auto;
            display: none; align-items: center; justify-content: center; font-size: 13px;
            z-index: 9992; user-select: none; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }
        #sc-flip-h-btn { right: 44px; }
        #sc-flip-v-btn { right: 44px; bottom: 44px; }
        #sc-flip-h-btn:hover, #sc-flip-v-btn:hover, #sc-lock-btn:hover { background: #eef2f5; }
        /* Bouton verrou pour l'overlay groupe */
        #sc-lock-btn {
            position: absolute; right: 14px; bottom: 14px;
            width: 24px; height: 24px; background: white; border: 1px solid #ccc;
            border-radius: 5px; cursor: pointer; pointer-events: auto;
            display: none; align-items: center; justify-content: center; font-size: 13px;
            z-index: 9992; user-select: none; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }
        #sc-lock-btn.locked { background: #4a90e2; color: white; border-color: #357abd; }

        /* --- S√âLECTION --- */
        .widget.selected, .widget.selected:focus-within {
            outline: 3px solid #4a90e2 !important;
            outline-offset: 6px;
            box-shadow: 0 0 0 6px rgba(74,144,226,0.25) !important;
        }
        .shape-widget.selected, .shape-widget.selected:focus-within {
            outline: 3px solid #4a90e2 !important;
            outline-offset: 6px;
            box-shadow: 0 0 0 6px rgba(74,144,226,0.25) !important;
        }
        /* Poign√©es visibles quand s√©lection UNIQUE uniquement */
        #board.single-select .widget.selected .drag-handle,
        #board.single-select .widget.selected .widget-close-handle,
        #board.single-select .widget.selected .widget-back-handle,
        #board.single-select .widget.selected .widget-rotate-handle,
        #board.single-select .widget.selected .widget-menu-handle,
        #board.single-select .shape-widget.selected .drag-handle,
        #board.single-select .shape-widget.selected .widget-close-handle,
        #board.single-select .shape-widget.selected .widget-back-handle,
        #board.single-select .shape-widget.selected .widget-rotate-handle,
        #board.single-select .shape-widget.selected .widget-menu-handle { opacity: 1; pointer-events: auto; }

        /* --- Sous-menu formes --- */
        #shape-toolbar {
            display: none; position: fixed; bottom: 80px; left: 30px;
            background: #1F1F21; border-radius: 14px; padding: 14px 16px;
            box-shadow: 0 -4px 30px rgba(0,0,0,0.4); z-index: 9998; border: 1px solid #3a3a3f;
            min-width: 320px;
        }
        #shape-toolbar.active { display: block; }
        .shape-toolbar-title { color: #aaa; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; }
        .shape-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 7px; margin-bottom: 12px; }
        .shape-choice {
            width: 54px; height: 54px; background: #2a2a2e; border: 2px solid #3a3a3f;
            border-radius: 10px; cursor: pointer; display: flex; align-items: center;
            justify-content: center; transition: 0.15s; flex-direction: column; gap: 3px;
        }
        .shape-choice:hover { border-color: #4a90e2; background: #1a3550; }
        .shape-choice.active { border-color: #4a90e2; background: #1a3550; box-shadow: 0 0 0 2px rgba(74,144,226,0.3); }
        .shape-choice svg { pointer-events: none; }
        .shape-choice-label { color: #777; font-size: 9px; pointer-events: none; text-align: center; line-height: 1; }
        .shape-controls { display: flex; align-items: center; gap: 14px; flex-wrap: wrap; border-top: 1px solid #333; padding-top: 10px; }
        .shape-controls label { color: #aaa; font-size: 11px; white-space: nowrap; }
        .shape-opacity-row { display: flex; align-items: center; gap: 8px; width: 100%; flex-wrap: wrap; }
        .shape-opacity-row label { color: #aaa; font-size: 11px; }
        #shape-opacity-slider { flex: 1; min-width: 80px; cursor: pointer; }
        #shape-opacity-val { color: #fff; font-size: 11px; min-width: 28px; }
        .shape-add-btn {
            margin-top: 10px; width: 100%; padding: 8px; background: #4a90e2;
            color: white; border: none; border-radius: 8px; cursor: pointer;
            font-weight: 600; font-size: 13px; transition: background 0.15s;
        }
        .shape-add-btn:hover { background: #357abd; }
        .shape-toolbar-close {
            position: absolute; top: 10px; right: 10px; background: none; border: none;
            color: #666; cursor: pointer; font-size: 16px; padding: 2px 6px; border-radius: 4px;
        }
        .shape-toolbar-close:hover { color: #fff; background: #444; }

        /* --- OVERLAY DE S√âLECTION --- */
        #selection-controls {
            position: absolute; pointer-events: none; z-index: 9990; display: none;
            border: 2px dashed rgba(74,144,226,0.8); border-radius: 4px;
            box-shadow: 0 0 0 1px rgba(74,144,226,0.15);
        }
        #selection-controls .sc-btn {
            position: absolute; width: 32px; height: 32px; background: #f8f9fa; border-radius: 6px;
            display: flex; align-items: center; justify-content: center; border: 1px solid #ddd;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2); cursor: pointer; pointer-events: auto;
            font-size: 15px; user-select: none; z-index: 9991;
        }
        #selection-controls .sc-move   { left: -16px; top: 50%; transform: translateY(-50%); color: #666; cursor: move; }
        #selection-controls .sc-rotate { right: -16px; top: 50%; transform: translateY(-50%); color: #8E51FF; cursor: grab; }
        #selection-controls .sc-rotate:active { cursor: grabbing; }
        #selection-controls .sc-delete { top: 5px; right: 5px; color: #ff5f56; }
        #selection-controls .sc-menu   { top: 5px; left: 5px; color: #555; }
        #selection-controls .sc-merge   { bottom: -18px; left: 50%; transform: translateX(-50%); color: #2bcbba; display: none; white-space: nowrap; width: auto; padding: 0 10px; font-size: 11px; font-weight: 600; }
        #selection-controls .sc-ungroup { bottom: -18px; left: 50%; transform: translateX(-50%); color: #f39c12; display: none; white-space: nowrap; width: auto; padding: 0 10px; font-size: 11px; font-weight: 600; }
        #selection-controls .sc-resize  { right: -8px; bottom: -8px; width: 18px; height: 18px; cursor: se-resize; font-size: 11px; color: #f39c12; background: white; border-color: #f39c12; border-radius: 3px; }
        #selection-controls .sc-btn:hover { background: white; }
        #selection-controls .sc-move:hover   { transform: translateY(-50%) scale(1.1); }
        #selection-controls .sc-rotate:hover { transform: translateY(-50%) scale(1.1); }
        #selection-controls .sc-merge:hover   { background: #e0faf8; transform: translateX(-50%) scale(1.05); }
        #selection-controls .sc-ungroup:hover { background: #fff8e6; transform: translateX(-50%) scale(1.05); }
        /* Membres d'un groupe au repos : bordure ambr√©e discr√®te sur les widgets texte uniquement */
        .widget[data-group-id]              { border-color: rgba(243,156,18,0.35) !important; box-shadow: none !important; }
        .widget[data-group-id]:focus-within { border-color: rgba(243,156,18,0.5)  !important; box-shadow: none !important; }
        /* Membres s√©lectionn√©s (groupe actif) : bordure bleue nette */
        .widget.selected[data-group-id]        { outline: 3px solid #4a90e2 !important; outline-offset: 6px; box-shadow: 0 0 0 6px rgba(74,144,226,0.25) !important; }
        .shape-widget.selected[data-group-id]  { outline: 3px solid #4a90e2 !important; outline-offset: 6px; box-shadow: 0 0 0 6px rgba(74,144,226,0.25) !important; }
        #sc-ctx-menu {
            position: absolute; top: 38px; left: 5px; background: #1F1F21;
            border: 1px solid #444; border-radius: 10px; padding: 5px 0;
            min-width: 175px; z-index: 9995; box-shadow: 0 6px 20px rgba(0,0,0,0.4);
            display: none; flex-direction: column; pointer-events: auto;
        }
        #sc-ctx-menu.open { display: flex; }
        #sc-ctx-menu button {
            background: none; border: none; color: #eee; padding: 7px 14px;
            text-align: left; cursor: pointer; font-size: 13px; display: flex;
            align-items: center; gap: 8px; white-space: nowrap;
        }
        #sc-ctx-menu button:hover { background: #333; }
        #sc-ctx-menu hr { border: none; border-top: 1px solid #444; margin: 4px 0; }

        /* --- CONTENU --- */
        .widget[data-type="date"], .widget[data-type="time"] { min-width: unset; width: auto; }
        .widget[data-type="date"] .editor-container, .widget[data-type="time"] .editor-container { resize: none; overflow: hidden; display: flex; flex-direction: column; justify-content: center; align-items: center; background: white; }
        .widget[data-type="date"]:hover .editor-container, .widget[data-type="time"]:hover .editor-container { resize: both; }
        .widget[data-type="date"] .editor-container { min-width: 150px; min-height: 180px; }
        .widget[data-type="time"] .editor-container { min-width: 120px; min-height: 80px; }
        .editor-toolbar { display: flex; visibility: hidden; opacity: 0; gap: 4px; padding: 0px 35px; background: #f8f9fa; border-bottom: 1px solid #eee; flex-wrap: wrap; align-items: center; min-height: 36px; }
        .widget:focus-within .editor-toolbar { visibility: visible; opacity: 1; }
        .widget-content { padding: 10px; flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        .editor-container { display: flex; flex-direction: column; border: 1px solid #eee; border-radius: 8px; background: white; flex-grow: 1; overflow: hidden; resize: none; min-width: 180px; min-height: 70px; }
        .widget:hover .editor-container { resize: both; }
        .editor-container::-webkit-resizer { background-color: transparent; }
        .widget:hover .editor-container::-webkit-resizer { background-color: #ccc; background-image: linear-gradient(135deg, transparent 50%, #333 50%, #333 60%, transparent 60%, transparent 70%, #333 70%, #333 80%, transparent 80%); }
        .editor-toolbar button, .editor-toolbar select, .editor-toolbar input { padding: 2px 4px; cursor: pointer; border: 1px solid #ddd; background: white; border-radius: 4px; font-size: 11px; height: 26px; box-sizing: border-box; }
        @font-face { font-family: 'KGPerfectPenmanship'; src: url('polices/KGPerfectPenmanship.ttf') format('truetype'); }
        @font-face { font-family: 'Andika'; src: url('polices/Andika.ttf') format('truetype'); }
        @font-face { font-family: 'OpenDyslexicLocal'; src: url('polices/OpenDyslexic-Regular.otf') format('opentype'); }
        @font-face { font-family: 'BelleAllureGS'; src: url('polices/BelleAllureGS-Gros.otf') format('opentype'); }
        .editor-content { padding: 10px; outline: none; overflow: auto; text-align: left; flex-grow: 1; }

        /* --- TOOLBAR & MENUS --- */
        #toolbar-container { position: fixed; bottom: 65px; left: 30px; display: flex; flex-direction: column; align-items: flex-start; z-index: 9999; }
        #tools-menu { display: none; background: #1F1F21; border-radius: 12px; padding: 10px; box-shadow: var(--shadow); margin-bottom: 15px; flex-direction: column; gap: 8px; min-width: 180px; border: 1px solid #eee; position: relative; max-height: 80vh; overflow-y: auto; overflow-x: hidden; }
        #tools-menu.active { display: flex; }
        #bg-submenu { display: none; position: fixed; left: 220px; bottom: 80px; background: white; border-radius: 12px; padding: 12px; box-shadow: var(--shadow); grid-template-columns: repeat(3, 1fr); gap: 10px; min-width: 240px; border: 1px solid #eee; z-index: 10001; }
        #bg-submenu.active { display: grid; }
        @media (max-width: 600px) { #bg-submenu { left: 30px; bottom: 120px; min-width: 200px; grid-template-columns: repeat(2, 1fr); } }
        .tool-btn { background: var(--primary-color); color: black; border: none; padding: 5px 5px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        .widget-btn { color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        .menu-btn { background: #cccccc; color: white; border: none; padding: 12px 30px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        .undo-btn { background: #cccccc; color: white; border: none; padding: 5px 10px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        .redo-btn { background: #cccccc; color: white; border: none; padding: 5px 10px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 10px; width: 100%; white-space: nowrap; }
        #main-tool-btn { background: #333; width: 100px; justify-content: center; }
        .exit-fs-btn { display: none; position: absolute; top: 10px; right: 10px; z-index: 99999; background: rgba(0,0,0,0.5); color: white; border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 14px; }
        :fullscreen .exit-fs-btn { display: block; }
        .bg-thumb { width: 70px; height: 50px; border-radius: 6px; border: 2px solid #eee; cursor: pointer; background-size: cover; background-position: center; transition: 0.2s; }
        .bg-thumb:hover { transform: scale(1.05); border-color: var(--primary-color); }

        /* --- CANVAS --- */
        #draw-canvas { position: absolute; top: 0; left: 0; z-index: 12000; cursor: crosshair; touch-action: none; }
        #draw-canvas.inactive { pointer-events: none; cursor: default; z-index: 500; }
        #selection-rect { position: absolute; border: 2px dashed #4a90e2; background: rgba(74,144,226,0.08); pointer-events: none; z-index: 600; display: none; }

        /* --- CALENDRIER & HORLOGE --- */
        .calendar-page { width: 100%; height: 100%; display: flex; flex-direction: column; border: 1px solid #ced4da; border-radius: 8px; overflow: hidden; background: white; text-align: center; position: relative; padding-top: 15px; box-sizing: border-box; }
        .calendar-page::before { content: "‚óè ‚óè ‚óè"; position: absolute; top: -8px; left: 0; right: 0; color: #8e9aaf; font-size: 1.5em; letter-spacing: 0.9em; text-shadow: 0 5px 0 #6c757d; }
        .calendar-header { background: #D17B6B; height: 20%; min-height: 30px; border-bottom: 2px solid #D17B6B; margin-bottom: 5px; }
        .calendar-body { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; padding: 5px; }
        .calendar-day-name   { font-size: 0.75em; font-weight: 700; color: #333; text-transform: lowercase; }
        .calendar-day-number { font-size: 2.2em; font-weight: 800; color: #2c3e50; line-height: 1em; margin: 0.12em 0; }
        .calendar-month      { font-size: 0.95em; font-weight: 600; color: #333; }
        .clock-time { font-weight: 800; color: var(--primary-color); font-family: 'Courier New', monospace; display: flex; align-items: baseline; justify-content: center; width: 100%; gap: 4px; }
        .clock-seconds { font-size: 0.5em; color: #888; margin-left: 0.1em; }
        .icon-transparency { display: inline-block; width: 16px; height: 16px; border: 1px solid #333; background-color: #fff; background-image: linear-gradient(45deg,#ddd 25%,transparent 25%),linear-gradient(-45deg,#ddd 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#ddd 75%),linear-gradient(-45deg,transparent 75%,#ddd 75%); background-size: 8px 8px; background-position: 0 0,0 4px,4px -4px,-4px 0px; vertical-align: middle; border-radius: 2px; }

        /* --- AGENDA --- */
        .agenda-container { display: flex; flex-direction: column; background: #fff; border-radius: 8px; border: 1px solid #eee; overflow: hidden; min-height: 200px; }
        .agenda-header-title { background: #2b7fff; color: white; padding: 10px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; font-family: 'Segoe UI', sans-serif; border-radius: 4px 4px 0 0; font-size: 1em; }
        .agenda-current-time { background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 4px; font-size: 0.9em; }
        .agenda-list { padding: 10px; flex-grow: 1; }
        .agenda-item { display: flex; align-items: center; gap: 10px; padding: 5px 0; border-bottom: 1px dashed #eee; position: relative; }
        .agenda-item:last-child { border-bottom: none; }
        .agenda-item.dragging { opacity: 0.5; background: #f0f7ff; border: 1px dashed var(--primary-color); }
        .agenda-time { font-weight: bold; color: #4a90e2; font-size: 1.2em; min-width: 45px; outline: none; cursor: text; }
        .agenda-text { outline: none; flex-grow: 1; font-size: 1.2em; color: #333; }
        .agenda-add-btn { background: #f8f9fa; border: none; border-top: 1px solid #eee; padding: 5px; cursor: pointer; color: #4a90e2; font-weight: bold; font-size: 1.2em; transition: background 0.2s; }
        .agenda-add-btn:hover { background: #eef2f5; color: #2c3e50; }
        .agenda-row-handle { cursor: grab; color: #ccc; padding: 0 5px; font-size: 0.75em; user-select: none; }
        .agenda-row-handle:active { cursor: grabbing; }
        .agenda-delete-row { cursor: pointer; color: #e74c3c; font-weight: bold; font-size: 1em; padding: 0 5px; opacity: 0; transition: opacity 0.2s; }
        .agenda-item:hover .agenda-delete-row { opacity: 1; }

        /* --- PANNEAU √âDITION FORME --- */
        #shape-edit-panel { display:none; position:fixed; background:#1F1F21; border-radius:14px; padding:14px 16px; box-shadow:0 -4px 30px rgba(0,0,0,0.4); z-index:10000; border:1px solid #3a3a3f; min-width:300px; }

        /* --- MODALES --- */
        #modal-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:20000; justify-content:center; align-items:center; }
        .modal-content { background:white; padding:30px; border-radius:var(--border-radius); box-shadow:var(--shadow); text-align:center; max-width:400px; width:90%; }
        .modal-content button { padding: 10px 20px; border-radius: 10px; font-weight: 600; cursor: pointer; }
        .modal-content .btn-cancel { border: 1px solid #ddd; background: #f8f9fa; color: var(--text-color); }
        .modal-content .btn-confirm { border: none; background: #ff4757; color: white; }
</style>
</head>
<body>

<div id="board">
    <div id="selection-controls">
        <div class="sc-btn sc-move"   id="sc-move-btn"   title="D√©placer">‚ú•</div>
        <div class="sc-btn sc-rotate" id="sc-rotate-btn" title="Faire pivoter">‚Üª</div>
        <div class="sc-btn sc-delete" id="sc-delete-btn" title="Supprimer">√ó</div>
        <div class="sc-btn sc-menu"   id="sc-menu-btn"   title="Menu">‚ò∞</div>
        <div class="sc-btn sc-resize"  id="sc-resize-btn"  title="Redimensionner le groupe">‚Üò</div>
        <div id="sc-lock-btn" title="Verrouiller les proportions (ou Shift)">üîì</div>
        <div id="sc-flip-h-btn" title="Sym√©trie horizontale">‚Üî</div>
        <div id="sc-flip-v-btn" title="Sym√©trie verticale">‚Üï</div>
        <div class="sc-btn sc-merge"   id="sc-merge-btn"   title="Grouper les widgets s√©lectionn√©s">‚äû Grouper</div>
        <div class="sc-btn sc-ungroup" id="sc-ungroup-btn" title="Dissocier le groupe">‚õìÔ∏è Dissocier</div>
        <div id="sc-ctx-menu"></div>
    </div>
</div>

<div id="toolbar-container">
    <div id="tools-menu">
        <button class="widget-btn" onclick="createWidget('youtube'); toggleMenu()" style="background:#E7180B;"><span>üé¨</span> Vid√©o YouTube</button>
        <button class="widget-btn" onclick="createWidget('outilsprofs'); toggleMenu()" style="background:#FF692A;"><span>üéí</span> OutilsProfs</button>
        <button class="widget-btn" onclick="createWidget('iframe'); toggleMenu()" style="background:#FFD230;"><span>üíª</span> Fen√™tre Web</button>
        <button class="widget-btn" onclick="createWidget('time'); toggleMenu()" style="background:#7CCF35;"><span>üïí</span> Heure</button>
        <button class="widget-btn" onclick="createWidget('date'); toggleMenu()" style="background:#679638;"><span>üìÖ</span> Date</button>
        <button class="widget-btn" onclick="createWidget('homework'); toggleMenu()" style="background:#3BB8DB;"><span>üìù</span> Devoirs</button>
        <button class="widget-btn" onclick="createWidget('text'); toggleMenu()" style="background:#2B7FFF;"><span>üñäÔ∏è</span> Texte</button>
        <button class="widget-btn" onclick="createWidget('agenda'); toggleMenu()" style="background:#8E51FF;">üìå Planning</button>
        <button class="widget-btn" onclick="createWidget('deficalme'); toggleMenu()" style="background:#480eb3;"><span>üßò</span> D√©fi Calme</button>
        <button class="widget-btn" onclick="createWidget('pdf'); toggleMenu()" style="background:#E74C3C;"><span>üìÑ</span> PDF</button>
        <hr style="width:100%;border:0;border-top:1px solid #eee;margin:5px 0;">
        <button class="widget-btn" style="background:#71717B;" onclick="toggleSubMenu(event)"><span>üñºÔ∏è</span> Choisir fond ‚ùØ</button>
        <div id="bg-submenu">
            <div class="bg-thumb" style="background-color:#eef2f5;" onclick="applyBackground('none');saveBg('none')" title="D√©faut"></div>
            <div class="bg-thumb" style="background-color:#2f3542;" onclick="applyBackground('#2f3542');saveBg('#2f3542')" title="Ardoise"></div>
            <div class="bg-thumb" style="background-color:#104626;" onclick="applyBackground('#104626');saveBg('#104626')" title="Vert Tableau"></div>
            <div class="bg-thumb" style="background-color:#BAA09B;" onclick="applyBackground('#BAA09B');saveBg('#BAA09B')" title="Vieux rose"></div>
            <div class="bg-thumb" style="background-color:#EDD9D5;" onclick="applyBackground('#EDD9D5');saveBg('#EDD9D5')" title="Beige"></div>
            <div class="bg-thumb" style="background-color:#000000;" onclick="applyBackground('#000000');saveBg('#000000')" title="Noir"></div>
            <button class="tool-btn" onclick="document.getElementById('bg-upload').click()" style="background:#8e44ad;padding:5px;font-size:10px;grid-column:span 3;border-radius:8px;"><span>üì∑</span> Importer image</button>
        </div>
    </div>

    <!-- Sous-menu Formes -->
    <div id="shape-toolbar" style="position:relative;">
        <button class="shape-toolbar-close" onclick="toggleShapeToolbar()" title="Fermer">‚úñ</button>
        <div class="shape-toolbar-title">Choisir une forme</div>
        <div class="shape-grid" id="shape-grid"></div>
        <div class="shape-controls">
            <label>Contour :</label>
            <input type="color" id="shape-stroke-color" value="#2c3e50" title="Couleur du contour">
            <label>√âpaisseur :</label>
            <input type="range" id="shape-stroke-width" min="1" max="20" value="4" style="width:70px;cursor:pointer;">
            <span id="shape-stroke-width-val" style="color:#fff;font-size:11px;min-width:20px;">4</span>
            <label>Remplissage :</label>
            <input type="color" id="shape-fill-color" value="#4a90e2" title="Couleur de remplissage">
        </div>
        <div class="shape-opacity-row" style="margin-top:10px;">
            <label>Opacit√© remplissage :</label>
            <input type="range" id="shape-opacity-slider" min="0" max="100" value="60">
            <span id="shape-opacity-val">60%</span>
        </div>
        <button class="shape-add-btn" onclick="addShapeWidget()">Ôºã Ajouter la forme</button>
    </div>

    <!-- Panneau d'√©dition d'une forme existante -->
    <div id="shape-edit-panel">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
            <span style="color:#aaa;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:1px;">Modifier la forme</span>
            <button onclick="closeShapeEditPanel()" style="background:none;border:none;color:#666;cursor:pointer;font-size:16px;padding:2px 6px;border-radius:4px;">‚úñ</button>
        </div>
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;border-top:1px solid #333;padding-top:10px;">
            <label style="color:#aaa;font-size:11px;">Contour :</label>
            <input type="color" id="edit-stroke-color" value="#2c3e50" onchange="applyShapeEdit()">
            <label style="color:#aaa;font-size:11px;">√âpaisseur :</label>
            <input type="range" id="edit-stroke-width" min="1" max="20" value="4" style="width:70px;cursor:pointer;" oninput="document.getElementById('edit-stroke-width-val').textContent=this.value+'px';applyShapeEdit()">
            <span id="edit-stroke-width-val" style="color:#fff;font-size:11px;min-width:28px;">4px</span>
        </div>
        <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;margin-top:8px;">
            <label style="color:#aaa;font-size:11px;">Remplissage :</label>
            <input type="color" id="edit-fill-color" value="#4a90e2" onchange="applyShapeEdit()">
            <label style="color:#aaa;font-size:11px;">Opacit√© :</label>
            <input type="range" id="edit-fill-opacity" min="0" max="100" value="60" style="width:70px;cursor:pointer;" oninput="document.getElementById('edit-fill-opacity-val').textContent=this.value+'%';applyShapeEdit()">
            <span id="edit-fill-opacity-val" style="color:#fff;font-size:11px;min-width:28px;">60%</span>
        </div>
    </div>

    <div id="draw-toolbar" style="display:none;position:fixed;bottom:80px;left:30px;background:#1F1F21;border-radius:12px;padding:12px 16px;box-shadow:0 -4px 20px rgba(0,0,0,0.3);z-index:9998;border:1px solid #444;min-width:420px;">
        <!-- S√©lection du mode dessin -->
        <div id="draw-mode-selector" style="display:flex;gap:6px;margin-bottom:10px;border-bottom:1px solid #333;padding-bottom:10px;">
            <button id="draw-mode-free-btn" onclick="setDrawMode('free')" style="flex:1;padding:7px 8px;border-radius:8px;border:2px solid #4a90e2;background:#1a3550;color:#fff;cursor:pointer;font-size:12px;font-weight:600;display:flex;align-items:center;justify-content:center;gap:5px;">
                ‚úèÔ∏è Dessin libre
            </button>
            <button id="draw-mode-shape-btn" onclick="setDrawMode('shape')" style="flex:1;padding:7px 8px;border-radius:8px;border:2px solid #444;background:#2a2a2e;color:#aaa;cursor:pointer;font-size:12px;font-weight:600;display:flex;align-items:center;justify-content:center;gap:5px;">
                üîµ Formes
            </button>
            <button id="draw-mode-text-btn" onclick="setDrawMode('text')" style="flex:1;padding:7px 8px;border-radius:8px;border:2px solid #444;background:#2a2a2e;color:#aaa;cursor:pointer;font-size:12px;font-weight:600;display:flex;align-items:center;justify-content:center;gap:5px;" title="Bient√¥t disponible">
                ‚úçÔ∏è √âcriture
            </button>
        </div>
        <!-- Contr√¥les communs -->
        <div style="display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
            <span style="color:#ccc;font-size:11px;">Couleur :</span>
            <input type="color" id="draw-color" value="#e84393" style="width:32px;height:28px;border:none;cursor:pointer;background:none;">
            <span style="color:#ccc;font-size:11px;">√âpaisseur :</span>
            <input type="range" id="draw-size" min="1" max="40" value="4" style="width:90px;cursor:pointer;">
            <span id="draw-size-label" style="color:#fff;font-size:12px;min-width:20px;">4</span>
            <!-- Options sp√©cifiques √† la reconnaissance de formes -->
            <div id="shape-recog-options" style="display:none;align-items:center;gap:8px;">
                <span style="color:#aaa;font-size:11px;">Remplissage :</span>
                <input type="color" id="shape-recog-fill" value="#4a90e2" style="width:28px;height:24px;border:none;cursor:pointer;background:none;">
                <span style="color:#aaa;font-size:11px;">Opacit√© :</span>
                <input type="range" id="shape-recog-opacity" min="0" max="100" value="30" style="width:70px;cursor:pointer;">
                <span id="shape-recog-opacity-val" style="color:#fff;font-size:11px;min-width:24px;">30%</span>
            </div>
            <button onclick="clearCanvas()" style="background:#ff4757;color:white;border:none;padding:5px 10px;border-radius:6px;cursor:pointer;font-size:12px;">üóëÔ∏è Effacer</button>
            <button onclick="stopDrawing()" style="background:#6c757d;color:white;border:none;padding:5px 10px;border-radius:6px;cursor:pointer;font-size:12px;">‚úñ Fermer</button>
        </div>
        <!-- Indicateur de mode formes -->
        <div id="shape-recog-hint" style="display:none;margin-top:8px;padding:5px 8px;background:#1a2e1a;border-radius:6px;border:1px solid #2d5a2d;">
            <span style="color:#7dba7d;font-size:11px;">üí° Dessinez un cercle, carr√©, rectangle ou triangle ‚Äî la forme sera reconnue √† la fin du trac√©</span>
        </div>
    </div>

    <div id="eraser-toolbar" style="display:none;position:fixed;bottom:80px;left:30px;background:#1F1F21;border-radius:12px;padding:12px 16px;box-shadow:0 -4px 20px rgba(0,0,0,0.3);z-index:9998;border:1px solid #444;">
        <div style="display:flex;align-items:center;gap:14px;flex-wrap:wrap;">
            <span style="color:#ccc;font-size:12px;font-weight:600;">üßπ Gomme</span>
            <span style="color:#ccc;font-size:11px;">Taille :</span>
            <input type="range" id="eraser-size" min="5" max="80" value="20" style="width:90px;cursor:pointer;" oninput="document.getElementById('eraser-size-label').textContent=this.value">
            <span id="eraser-size-label" style="color:#fff;font-size:12px;min-width:20px;">20</span>
            <button onclick="stopEraserMode()" style="background:#6c757d;color:white;border:none;padding:5px 10px;border-radius:6px;cursor:pointer;font-size:12px;">‚úñ Fermer</button>
        </div>
    </div>

    <div id="global-toolbar" style="position:fixed;bottom:80px;left:30px;right:30px;background:#1F1F21;border-radius:12px;display:none;padding:10px 15px;box-shadow:0 -4px 20px rgba(0,0,0,0.3);z-index:9998;border:1px solid #444;">
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
            <button onmousedown="savedSelection=saveCurrentSelection()" onclick="formatGlobal('bold')" title="Gras"><b>G</b></button>
            <button onmousedown="savedSelection=saveCurrentSelection()" onclick="formatGlobal('italic')" title="Italique"><i>I</i></button>
            <button onmousedown="savedSelection=saveCurrentSelection()" onclick="formatGlobal('underline')" title="Soulign√©"><u>S</u></button>
            <span style="font-size:10px;color:#ccc;">Texte :</span>
            <input type="color" onmousedown="savedSelection=saveCurrentSelection()" onchange="applyTextColor(this.value)" title="Couleur du texte">
            <span style="font-size:10px;color:#ccc;">Surligner :</span>
            <input type="color" onmousedown="savedSelection=saveCurrentSelection()" onchange="applyHighlightColor(this.value)" title="Surligner" value="#ffff00">
            <span style="font-size:10px;color:#ccc;">Fond widget :</span>
            <input type="color" onchange="changeWidgetBgGlobal(this,this.value)" title="Fond du cadre" value="#ffffff">
            <button onmousedown="savedSelection=saveCurrentSelection()" onclick="toggleTransparencyGlobal()" title="Fond transparent"><span class="icon-transparency"></span></button>
            <select onmousedown="savedSelection=saveCurrentSelection()" onchange="formatFontFamilyGlobal(this.value)" style="width:140px;">
                <option value="Arial, sans-serif">Arial</option>
                <option value="'Segoe UI', sans-serif">Segoe UI</option>
                <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                <option value="Verdana, sans-serif">Verdana</option>
                <option value="'KGPerfectPenmanship', sans-serif">KGPerfectPenmanship</option>
                <option value="'Andika', sans-serif">Andika</option>
                <option value="'OpenDyslexicLocal', sans-serif">üß© OpenDyslexic</option>
                <option value="'BelleAllureGS', cursive">üìè Belle Allure GS</option>
            </select>
            <input type="number" id="font-size-input" value="40" min="8" max="100"
              onmousedown="savedSelection=saveCurrentSelection()"
              onkeydown="if(event.key==='Enter'){applyFontSizeOnBlur(this);this.blur();}"
              onblur="applyFontSizeOnBlur(this)" style="width:40px;">
            <button onclick="closeGlobalToolbar()" style="margin-left:auto;background:#6c757d;color:white;padding:4px 8px;border-radius:4px;">‚úñ</button>
        </div>
    </div>

    <!-- Barre du bas -->
    <div style="position:fixed;bottom:30px;left:0;right:0;display:flex;align-items:center;padding:0 30px;gap:10px;z-index:9999;pointer-events:none;">
        <div style="display:flex;gap:10px;align-items:center;pointer-events:auto;">
            <button id="main-tool-btn" class="menu-btn" onclick="toggleMenu()" style="border:2px solid rgba(0,0,0,0.5);box-sizing:border-box; font-size:15px;">WIDGETS</button>
            <button id="undo-btn" class="undo-btn" onclick="undoAction()" style="background:#111111;opacity:0.4;cursor:not-allowed;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Annuler">‚Ü©</button>
            <button id="redo-btn" class="redo-btn" onclick="redoAction()" style="background:#111111;opacity:0.4;cursor:not-allowed;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Refaire">‚Ü™</button>
            <button id="draw-btn" class="tool-btn" onclick="toggleDrawToolbar()" style="background:#eeeeee;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Outil dessin">‚úèÔ∏è</button>
            <button id="eraser-btn" class="tool-btn" onclick="toggleEraserMode()" style="background:#eeeeee;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Gomme">üßπ</button>
            <button id="shape-btn" class="tool-btn" onclick="toggleShapeToolbar()" style="background:#eeeeee;cursor:pointer;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Ajouter une forme">üî≤</button>
            <button id="toolbar-toggle-btn" class="tool-btn" onclick="toggleGlobalToolbar()" style="background:#eeeeee;cursor:pointer;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Outils texte">üñäÔ∏è</button>
        </div>
        <div style="flex:1;"></div>
        <div style="display:flex;gap:10px;align-items:center;pointer-events:auto;">
            <button class="tool-btn" onclick="exportConfig()" style="background:#eeeeee;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Sauvegarder">üíæ</button>
            <button class="tool-btn" onclick="document.getElementById('import-input').click()" style="background:#eeeeee;border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Charger">üìÇ</button>
            <input type="file" id="import-input" style="display:none" accept=".json" onchange="importConfig(event)">
            <button class="tool-btn" onclick="clearBoard()" style="background:#eeeeee; border:2px solid rgba(255,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Effacer tout">‚ùå</button>
            <button class="tool-btn" onclick="openHelpModal()" style="background:#eeeeee; border:2px solid rgba(0,0,0,0.5);box-sizing:border-box;font-size:20px;" title="Aide">‚ùì</button>
        </div>
    </div>
</div>

<div id="modal-overlay">
    <div class="modal-content">
        <h3 style="margin-top:0;color:#ff4757;">‚ö†Ô∏è Tout effacer ?</h3>
        <p style="color:#666;">Cette action videra votre bureau. C'est irr√©versible.</p>
        <div style="display:flex;gap:10px;justify-content:center;margin-top:20px;">
            <button class="btn-cancel" onclick="closeModal()">Annuler</button>
            <button class="btn-confirm" onclick="confirmClearBoard()">Oui, vider tout</button>
        </div>
    </div>
</div>

<div id="help-modal-overlay" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.55);z-index:20010;justify-content:center;align-items:center;">
    <div class="modal-content" style="max-width:640px;width:92%;text-align:left;max-height:80vh;overflow:auto;padding:24px;">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;">
            <div>
                <h3 style="margin:0 0 6px 0;">Aide ‚Äì Le Bureau du Prof</h3>
                <p style="margin:0 0 10px 0;color:#555;font-size:13px;">Voici les fonctions principales pour utiliser le bureau au quotidien.</p>
            </div>
            <button onclick="closeHelpModal()" style="border:1px solid #ddd;background:#f8f9fa;border-radius:10px;width:32px;height:32px;cursor:pointer;font-size:18px;line-height:1;">√ó</button>
        </div>
        <h4 style="margin:14px 0 4px 0;">1. S√©lectionner et d√©placer des widgets</h4>
        <ul style="margin:4px 0 10px 18px;font-size:13px;color:#333;">
            <li>Cliquez sur un widget pour le s√©lectionner (bordure bleue). Cliquez-glissez sur le fond pour s√©lectionner une zone.</li>
            <li>Utilisez la poign√©e <b>‚ú•</b> √† gauche pour d√©placer. <b>üìå</b> √©pingle au premier plan, <b>üîΩ</b> envoie derri√®re, <b>√ó</b> ferme.</li>
            <li>Le bouton <b>‚ò∞</b> (bas du widget) donne acc√®s √† dupliquer et modifier.</li>
        </ul>
        <h4 style="margin:10px 0 4px 0;">2. Formes g√©om√©triques</h4>
        <ul style="margin:4px 0 10px 18px;font-size:13px;color:#333;">
            <li>Cliquez sur <b>üî≤</b> pour ouvrir le panneau des formes. Double-cliquez sur une forme pour modifier ses couleurs.</li>
        </ul>
        <h4 style="margin:10px 0 4px 0;">3. Sauvegarder et charger</h4>
        <ul style="margin:4px 0 10px 18px;font-size:13px;color:#333;">
            <li><b>üíæ</b> exporte en fichier .json, <b>üìÇ</b> recharge un bureau sauvegard√©.</li>
        </ul>
        <div style="text-align:right;margin-top:10px;">
            <button class="btn-cancel" onclick="closeHelpModal()">Fermer</button>
        </div>
    </div>
</div>

<!-- TEMPLATES -->
<template id="template-text">
    <div class="editor-container">
        <div class="editor-content" contenteditable="true" oninput="saveBoard()" style="font-size:40px;"></div>
    </div>
</template>
<template id="template-homework">
    <div class="editor-container">
        <div class="editor-content" contenteditable="true" oninput="saveBoard()">
            <span style="color:#D4C9C7;font-size:25px;font-weight:bold;">‚úçüèª Devoirs √† noter </span><br>
            <p><span style="color:red;background-color:#F7E02A;font-size:38px;font-weight:bold;">Pour</span></p>
            <p><span style="color:#f7639f;font-size:35px;font-weight:bold;">&nbsp;&nbsp;üëâüèª CE2 =</span></p>
            <p><span style="color:#12a2e0;font-size:35px;font-weight:bold;">&nbsp;&nbsp;üëâüèΩ CM2 =</span></p>
            <p><span style="color:#D9C93B;font-size:35px;font-weight:bold;">&nbsp;&nbsp;üëâ TOUS =</span></p>
        </div>
    </div>
</template>
<template id="template-date">
    <div class="editor-container" style="width:220px;height:260px;">
        <div class="editor-toolbar" style="justify-content:center;border-bottom:none;">
            <button onclick="toggleTransparency(this)" title="Fond transparent">ü´•</button>
        </div>
        <div class="calendar-page" style="font-size:16px;">
            <div class="calendar-header"></div>
            <div class="calendar-body">
                <div class="calendar-day-name"></div>
                <div class="calendar-day-number"></div>
                <div class="calendar-month"></div>
            </div>
        </div>
    </div>
</template>
<template id="template-time">
    <div class="editor-container" style="width:200px;height:100px;">
        <div class="clock-time" style="font-size:32px;">
            <span class="clock-hm">00:00</span><span class="clock-seconds">00</span>
        </div>
    </div>
</template>
<template id="template-iframe">
    <div class="editor-container" style="height:400px;width:550px;">
        <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
        <div class="editor-toolbar">
            <input type="text" placeholder="Collez l'URL ici..." style="flex-grow:1;" onchange="loadIframe(this)">
            <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂</button>
        </div>
        <iframe src="" style="flex-grow:1;border:none;background:white;" allow="microphone;camera;display-capture;autoplay"></iframe>
    </div>
</template>
<template id="template-outilsprofs">
    <div class="editor-container" style="height:500px;width:800px;">
        <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
        <div class="editor-toolbar" style="display:flex;justify-content:flex-end;">
            <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
        <iframe src="https://ecolebernardet.github.io/outilsprofs" style="flex-grow:1;border:none;background:white;" allow="microphone;camera;display-capture;autoplay"></iframe>
    </div>
</template>
<template id="template-youtube">
    <div class="editor-container" style="height:350px;width:600px;">
        <div class="editor-toolbar">
            <input type="text" placeholder="Collez le lien YouTube ici..." style="flex-grow:1;" onchange="loadYoutube(this)">
            <button onclick="toggleYoutubeView(this,'none')" title="Mode Audio">üîá Son seul</button>
            <button onclick="toggleYoutubeView(this,'block')" title="Mode Vid√©o">üì∫ Vid√©o</button>
            <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂</button>
            <button onclick="toggleTransparency(this)" title="Fond transparent"><span class="icon-transparency"></span></button>
        </div>
        <iframe src="" style="flex-grow:1;border:none;background:#000;" allow="accelerometer;autoplay;clipboard-write;encrypted-media;gyroscope;picture-in-picture;web-share" allowfullscreen></iframe>
    </div>
</template>
<template id="template-agenda">
    <div class="editor-container">
        <div class="agenda-container" style="font-size:16px;">
            <div class="agenda-header-title">
                <span class="agenda-current-date"></span>
                <span class="agenda-current-time"></span>
            </div>
            <div class="agenda-list">
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><span class="agenda-time" contenteditable="true">08:30</span><div class="agenda-text" contenteditable="true">Accueil / Appel / Rituels</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><span class="agenda-time" contenteditable="true">09:15</span><div class="agenda-text" contenteditable="true">Fran√ßais</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><span class="agenda-time" contenteditable="true">10:20</span><div class="agenda-text" contenteditable="true">R√©cr√©ation</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">10:45</div><div class="agenda-text" contenteditable="true">Math√©matiques</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">11:45</div><div class="agenda-text" contenteditable="true">Fin de la matin√©e</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">--:--</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">13:45</div><div class="agenda-text" contenteditable="true">Rituel / Quart d'heure lecture</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">14:00</div><div class="agenda-text" contenteditable="true">Mati√®re</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">15:20</div><div class="agenda-text" contenteditable="true">R√©cr√©ation</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">15:45</div><div class="agenda-text" contenteditable="true">Mati√®re</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
                <div class="agenda-item" draggable="true"><span class="agenda-row-handle">‚ãÆ‚ãÆ</span><div class="agenda-time" contenteditable="true">16:30</div><div class="agenda-text" contenteditable="true">Fin de la journ√©e</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span></div>
            </div>
            <button class="agenda-add-btn" onclick="addAgendaLine(this)" title="Ajouter une ligne">+</button>
        </div>
    </div>
</template>
<template id="template-deficalme">
    <div class="editor-container" style="height:500px;width:800px;">
        <button class="exit-fs-btn" onclick="document.exitFullscreen()">‚úñ Quitter Plein √âcran</button>
        <div class="editor-toolbar" style="display:flex;justify-content:flex-end;">
            <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
        <iframe src="https://ecolebernardet.github.io/lebureauduprof/deficalme.html" style="flex-grow:1;border:none;background:white;" allow="microphone;camera;display-capture;autoplay"></iframe>
    </div>
</template>
<template id="template-pdf">
    <div class="editor-container" style="height:500px;width:600px;">
        <div class="editor-toolbar" style="gap:8px;">
            <label style="cursor:pointer;background:#4a90e2;color:white;padding:3px 8px;border-radius:5px;font-size:11px;">
                üìÑ Ouvrir PDF
                <input type="file" accept=".pdf" style="display:none" onchange="loadPdfWidget(this)">
            </label>
            <button onclick="toggleFullScreen(this.closest('.editor-container'))" title="Plein √©cran">‚õ∂ Plein √©cran</button>
        </div>
        <embed src="" type="application/pdf" style="flex-grow:1;width:100%;border:none;">
    </div>
</template>

<div id="rotation-indicator"><span id="rot-deg">0¬∞</span><span class="rot-reset-hint">double-clic ‚Üí 0¬∞</span></div>
<input type="file" id="bg-upload" style="display:none" accept="image/*" onchange="handleBgUpload(this)">

<script>
// =========================================================================
// VARIABLES GLOBALES
// =========================================================================
let board = document.getElementById('board');
let undoStack = [], redoStack = [];
const MAX_UNDO = 60;
let isInitialLoading = true;
let isRestoringState = false;
let _pendingSnapshotTimer = null;
let savedSelection = null;
let currentActiveWidget = null;
const RATIO = 16 / 9;
let _lastW = window.innerWidth;

// =========================================================================
// INIT
// =========================================================================
window.onload = () => {
    const savedBg = localStorage.getItem('boardBackground');
    if (savedBg) applyBackground(savedBg);
    applyBoardRatio(window.innerWidth);
    loadBoard();
    initShapeToolbar();
    setTimeout(() => {
        isInitialLoading = false;
        _lastW = window.innerWidth;
        initSelectionControls();
        initBoardSelection();
        const fontSizeInput = document.getElementById('font-size-input');
        if (fontSizeInput) {
            fontSizeInput.addEventListener('focus', () => {
                if (!currentActiveWidget) return;
                const sel = window.getSelection();
                if (sel.rangeCount > 0) savedSelection = sel.getRangeAt(0).cloneRange();
            });
        }
        const cur = buildBoardJSON();
        if (cur) undoStack.push(cur);
        updateUndoRedoBtns();
    }, 1000);
    setInterval(updateClock, 1000);
    window.addEventListener('resize', handleWindowResize);
};

// =========================================================================
// RATIO 16:9
// =========================================================================
function virtualH(w) { return w / RATIO; }

function applyBoardRatio(newW) {
    const vh = virtualH(newW);
    board.style.width    = newW + 'px';
    board.style.height   = vh + 'px';
    board.style.position = 'absolute';
    board.style.top      = Math.max(0, (window.innerHeight - vh) / 2) + 'px';
    board.style.left     = '0';
}

function scaleFontSizesBy(el, factor) {
    if (Math.abs(factor - 1) < 0.001) return;
    el.querySelectorAll('*').forEach(child => {
        if (!child.style?.fontSize) return;
        const m = child.style.fontSize.match(/^([\d.]+)px$/);
        if (m) child.style.fontSize = (parseFloat(m[1]) * factor) + 'px';
    });
    if (el.style?.fontSize) {
        const m = el.style.fontSize.match(/^([\d.]+)px$/);
        if (m) el.style.fontSize = (parseFloat(m[1]) * factor) + 'px';
    }
}

function scaleFontSizesFromRef(el, refW) { scaleFontSizesBy(el, window.innerWidth / refW); }

function getToolbarHeight(container) {
    const tb = container?.querySelector('.editor-toolbar');
    return tb ? tb.offsetHeight : 0;
}

function handleWindowResize() {
    const newW = window.innerWidth;
    const factor = newW / _lastW;
    applyBoardRatio(newW);
    const newVH = virtualH(newW);
    document.querySelectorAll('.widget').forEach(w => {
        const c = w.querySelector('.editor-container');
        if (c) {
            if (parseFloat(w.dataset.widthPercent) > 0)
                c.style.width = (parseFloat(w.dataset.widthPercent) / 100) * newW + 'px';
            if (parseFloat(w.dataset.contentHPercent) > 0)
                c.style.height = ((parseFloat(w.dataset.contentHPercent) / 100) * newVH) + getToolbarHeight(c) + 'px';
        }
        if (parseFloat(w.dataset.leftPercent) > 0) w.style.left = (parseFloat(w.dataset.leftPercent) / 100) * newW + 'px';
        if (parseFloat(w.dataset.topPercent)  > 0) w.style.top  = (parseFloat(w.dataset.topPercent)  / 100) * newVH + 'px';
        scaleFontSizesBy(w, factor);
    });
    document.querySelectorAll('.shape-widget').forEach(w => {
        const curW = newW, curVH = virtualH(curW);
        if (parseFloat(w.dataset.leftPercent) > 0) w.style.left = (parseFloat(w.dataset.leftPercent) / 100) * curW + 'px';
        if (parseFloat(w.dataset.topPercent)  > 0) w.style.top  = (parseFloat(w.dataset.topPercent)  / 100) * curVH + 'px';
        const svg = w.querySelector('svg');
        if (svg && parseFloat(w.dataset.wPercent) > 0) {
            const sw = (parseFloat(w.dataset.wPercent) / 100) * curW;
            const sh = (parseFloat(w.dataset.hPercent) / 100) * curVH;
            svg.setAttribute('width', sw);
            svg.setAttribute('height', sh);
        }
    });
    _lastW = newW;
    resizeCanvas();
}

// =========================================================================
// UNDO / REDO
// =========================================================================
function snapshotNow() {
    if (isInitialLoading || isRestoringState) return;
    clearTimeout(_pendingSnapshotTimer);
    const cur = buildBoardJSON();
    if (!cur) return;
    if (undoStack.length > 0 && undoStack[undoStack.length - 1] === cur) return;
    undoStack.push(cur);
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack = [];
    updateUndoRedoBtns();
}

function scheduleSaveSnapshot() {
    clearTimeout(_pendingSnapshotTimer);
    _pendingSnapshotTimer = setTimeout(() => {
        const cur = buildBoardJSON();
        if (!cur) return;
        if (undoStack.length > 0 && undoStack[undoStack.length - 1] === cur) return;
        undoStack.push(cur);
        if (undoStack.length > MAX_UNDO) undoStack.shift();
        redoStack = [];
        updateUndoRedoBtns();
    }, 800);
}

function undoAction() {
    if (undoStack.length <= 1) return;
    isRestoringState = true;
    clearTimeout(_pendingSnapshotTimer);
    redoStack.push(undoStack.pop());
    const snap = undoStack[undoStack.length - 1];
    document.querySelectorAll('.widget').forEach(w => w.remove());
    document.querySelectorAll('.shape-widget').forEach(w => w.remove());
    try {
        const p = JSON.parse(snap);
        strokes = p.strokes || [];
        if (p.background) { localStorage.setItem('boardBackground', p.background); applyBackground(p.background); }
    } catch(e) { strokes = []; }
    localStorage.setItem('profBoardConfig', snap);
    _lastW = window.innerWidth;
    restoreBoardFromJSON(snap);
    isRestoringState = false;
    updateUndoRedoBtns();
}

function redoAction() {
    if (redoStack.length === 0) return;
    isRestoringState = true;
    clearTimeout(_pendingSnapshotTimer);
    const snap = redoStack.pop();
    undoStack.push(snap);
    document.querySelectorAll('.widget').forEach(w => w.remove());
    document.querySelectorAll('.shape-widget').forEach(w => w.remove());
    try {
        const p = JSON.parse(snap);
        strokes = p.strokes || [];
        if (p.background) { localStorage.setItem('boardBackground', p.background); applyBackground(p.background); }
    } catch(e) { strokes = []; }
    localStorage.setItem('profBoardConfig', snap);
    _lastW = window.innerWidth;
    restoreBoardFromJSON(snap);
    isRestoringState = false;
    updateUndoRedoBtns();
}

function updateUndoRedoBtns() {
    const ub = document.getElementById('undo-btn'), rb = document.getElementById('redo-btn');
    const canU = undoStack.length > 1, canR = redoStack.length > 0;
    if (ub) { ub.style.opacity = canU ? '1' : '0.4'; ub.style.cursor = canU ? 'pointer' : 'not-allowed'; }
    if (rb) { rb.style.opacity = canR ? '1' : '0.4'; rb.style.cursor = canR ? 'pointer' : 'not-allowed'; }
}

// =========================================================================
// SAUVEGARDE / CHARGEMENT
// =========================================================================
function getInnerHTMLNormalized(widget) {
    const factor = 1920 / window.innerWidth;
    const clone = widget.cloneNode(true);
    clone.querySelectorAll('*').forEach(el => {
        if (!el.style?.fontSize) return;
        const m = el.style.fontSize.match(/^([\d.]+)px$/);
        if (m) el.style.fontSize = (parseFloat(m[1]) * factor) + 'px';
    });
    if (clone.style?.fontSize) {
        const m = clone.style.fontSize.match(/^([\d.]+)px$/);
        if (m) clone.style.fontSize = (parseFloat(m[1]) * factor) + 'px';
    }
    const agendaList = clone.querySelector('.agenda-list');
    const content    = clone.querySelector('.editor-content');
    return agendaList ? agendaList.innerHTML : (content ? content.innerHTML : null);
}

function getEditorStyleNormalized(widget, refWidth = 1920) {
    const editor = widget.querySelector('.editor-content');
    if (!editor) return null;
    const cs = window.getComputedStyle(editor);
    const curW = window.innerWidth || refWidth;
    const factor = refWidth / curW;
    const fontSizePx = parseFloat(cs.fontSize);
    return {
        fontFamily: cs.fontFamily || '',
        fontSizePx: Number.isFinite(fontSizePx) ? +(fontSizePx * factor).toFixed(2) : null,
        color: cs.color || ''
    };
}

function applyEditorStyleFromConfig(widget, style) {
    if (!style) return;
    const editor = widget.querySelector('.editor-content');
    if (!editor) return;
    if (style.fontFamily) editor.style.fontFamily = style.fontFamily;
    if (style.color) editor.style.color = style.color;
    if (style.fontSizePx) editor.style.fontSize = style.fontSizePx + 'px';
}

function buildBoardState() {
    const curW = window.innerWidth, curVH = virtualH(curW);
    const widgets = [];
    document.querySelectorAll('.widget').forEach(w => {
        const iframe = w.querySelector('iframe');
        const c = w.querySelector('.editor-container');
        const html = getInnerHTMLNormalized(w);
        const isTextLike = w.dataset.type === 'text' || w.dataset.type === 'homework';
        let wP = 0, hP = 0;
        if (c) { wP = (c.offsetWidth / curW) * 100; hP = ((c.offsetHeight - getToolbarHeight(c)) / curVH) * 100; }
        const lP = (w.offsetLeft / curW) * 100;
        const tP = (w.offsetTop  / curVH) * 100;
        Object.assign(w.dataset, { widthPercent: wP, contentHPercent: hP, leftPercent: lP, topPercent: tP });
        widgets.push({
            type: w.dataset.type, topPercent: tP, leftPercent: lP, widthPercent: wP, contentHPercent: hP,
            html, content: html, iframeSrc: iframe?.src || null,
            transparent: w.dataset.transparent === "true",
            bgColor: w.dataset.bgColor || "#ffffff",
            editorStyle: isTextLike ? getEditorStyleNormalized(w, 1920) : null,
            pinned: w.dataset.pinned === "true",
            background: w.dataset.background === "true",
            groupId: w.dataset.groupId || null
        });
    });
    const shapes = [];
    document.querySelectorAll('.shape-widget').forEach(w => {
        const svg = w.querySelector('svg');
        if (!svg) return;
        const lP = (w.offsetLeft / curW) * 100;
        const tP = (w.offsetTop  / curVH) * 100;
        const wP = (parseFloat(svg.getAttribute('width') || 150) / curW) * 100;
        const hP = (parseFloat(svg.getAttribute('height') || 150) / curVH) * 100;
        w.dataset.leftPercent = lP; w.dataset.topPercent = tP;
        w.dataset.wPercent = wP; w.dataset.hPercent = hP;
        shapes.push({
            shapeType: w.dataset.shapeType, strokeColor: w.dataset.strokeColor,
            fillColor: w.dataset.fillColor, fillOpacity: w.dataset.fillOpacity,
            strokeWidth: parseInt(w.dataset.strokeWidth || 4),
            leftPercent: lP, topPercent: tP, wPercent: wP, hPercent: hP,
            transform: w.style.transform || '', pinned: w.dataset.pinned === "true",
            background: w.dataset.background === "true",
            groupId: w.dataset.groupId || null,
            flipX: parseFloat(w.dataset.flipX || 1),
            flipY: parseFloat(w.dataset.flipY || 1)
        });
    });
    return { widgets, shapes, refWidth: 1920, background: localStorage.getItem('boardBackground') || 'none', strokes: strokes || [] };
}

function buildBoardJSON() {
    try { return JSON.stringify(buildBoardState()); } catch(e) { return null; }
}

function saveBoard() {
    if (isInitialLoading || isRestoringState) return;
    localStorage.setItem('profBoardConfig', JSON.stringify(buildBoardState()));
    scheduleSaveSnapshot();
}

function loadBoard() {
    const raw = localStorage.getItem('profBoardConfig');
    if (!raw) return;
    restoreBoardFromJSON(raw);
}

function restoreBoardFromJSON(json) {
    const parsed = JSON.parse(json);
    const data = Array.isArray(parsed) ? parsed : (parsed.widgets || []);
    const refW = parsed.refWidth || 1920;
    // Restaurer les traits canvas si pr√©sents dans le snapshot
    if (parsed.strokes && parsed.strokes.length > 0) {
        strokes = parsed.strokes;
        // Initialiser le canvas silencieusement si pas encore cr√©√©
        if (!drawCanvas) {
            initCanvas();
            // Garder le canvas inactif (pas en mode dessin)
            drawCanvas.classList.add('inactive');
        }
        // Laisser le DOM se stabiliser avant de dessiner
        setTimeout(() => redrawStrokes(), 100);
    }
    const curW = window.innerWidth, curVH = virtualH(curW);
    data.forEach(w => {
        const widget = createWidget(w.type, '100px', '100px', false);
        const c = widget.querySelector('.editor-container');
        const hP = w.contentHPercent !== undefined ? w.contentHPercent : w.heightPercent;
        Object.assign(widget.dataset, { widthPercent: w.widthPercent || 0, contentHPercent: hP || 0, leftPercent: w.leftPercent ?? 0, topPercent: w.topPercent ?? 0 });
        if (c) {
            if (w.widthPercent > 0) c.style.width = (w.widthPercent / 100) * curW + 'px';
            if (hP > 0) c.style.height = ((hP / 100) * curVH) + getToolbarHeight(c) + 'px';
        }
        widget.style.left = (w.leftPercent / 100) * curW + 'px';
        widget.style.top  = (w.topPercent  / 100) * curVH + 'px';
        // Appliquer transparence et fond imm√©diatement pour √©viter le flash
        if (w.transparent) applyTransparency(widget, true);
        else if (w.bgColor) { widget.style.background = w.bgColor; widget.dataset.bgColor = w.bgColor; const c2 = widget.querySelector('.editor-container'); if (c2) c2.style.background = w.bgColor; }
        if (w.background) { widget.style.zIndex = 1; widget.dataset.background = "true"; }
        else if (w.pinned) bringToFront(widget, true);
        if (w.groupId) widget.dataset.groupId = w.groupId;
        setTimeout(() => {
            const editor = widget.querySelector('.editor-content');
            const agenda = widget.querySelector('.agenda-list');
            const htmlContent = w.html ?? w.content ?? null;
            if (htmlContent) {
                if (agenda) { agenda.innerHTML = htmlContent; agenda.querySelectorAll('.agenda-item').forEach(attachAgendaItemEvents); }
                else if (editor) { editor.innerHTML = htmlContent; }
            }
            const iframe = widget.querySelector('iframe');
            if (w.iframeSrc && iframe) iframe.src = w.iframeSrc;
            applyEditorStyleFromConfig(widget, w.editorStyle);
            scaleFontSizesFromRef(widget, refW);
        }, 50);
    });
    if (parsed.shapes) {
        parsed.shapes.forEach(s => {
            const curW2 = window.innerWidth, curVH2 = virtualH(curW2);
            const sw = (s.wPercent / 100) * curW2, sh = (s.hPercent / 100) * curVH2;
            const lx = (s.leftPercent / 100) * curW2, ty = (s.topPercent / 100) * curVH2;
            const w2 = createShapeWidget(s.shapeType, s.strokeColor, s.fillColor, s.fillOpacity, sw, sh, lx + 'px', ty + 'px', false, s.strokeWidth || 4);
            if (s.transform) w2.style.transform = s.transform;
            if (s.flipX !== undefined) w2.dataset.flipX = s.flipX;
            if (s.flipY !== undefined) w2.dataset.flipY = s.flipY;
            // R√©-appliquer le flip sur le SVG (pas sur le widget entier)
            const fsx = parseFloat(s.flipX || 1), fsy = parseFloat(s.flipY || 1);
            if (fsx !== 1 || fsy !== 1) {
                const svg2 = w2.querySelector('svg');
                if (svg2) {
                    const sw2 = parseFloat(svg2.getAttribute('width'))  || 0;
                    const sh2 = parseFloat(svg2.getAttribute('height')) || 0;
                    svg2.style.transformBox    = 'fill-box';
                    svg2.style.transformOrigin = 'center center';
                    svg2.style.transform       = `scale(${fsx}, ${fsy})`;
                }
            }
            if (s.background) { w2.style.zIndex = 1; w2.dataset.background = "true"; }
            else if (s.pinned) bringToFront(w2, true);
            if (s.groupId) w2.dataset.groupId = s.groupId;
            w2.dataset.leftPercent = s.leftPercent; w2.dataset.topPercent = s.topPercent;
            w2.dataset.wPercent = s.wPercent; w2.dataset.hPercent = s.hPercent;
        });
    }
}

function exportConfig() {
    const state = buildBoardState();
    const a = document.createElement('a');
    a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state));
    a.download = `lebureauduprof_export_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a); a.click(); a.remove();
}

function importConfig(event) {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            snapshotNow();
            document.querySelectorAll('.widget').forEach(w => w.remove());
            document.querySelectorAll('.shape-widget').forEach(w => w.remove());
            applyBackground(data.background || 'none'); saveBg(data.background || 'none');
            localStorage.setItem('profBoardConfig', JSON.stringify(data));
            restoreBoardFromJSON(JSON.stringify(data));
            event.target.value = '';
        } catch(err) { alert("Erreur : " + err.message); }
    };
    reader.readAsText(file);
}

function clearBoard() { document.getElementById('modal-overlay').style.display = 'flex'; }
function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
function confirmClearBoard() {
    snapshotNow();
    document.querySelectorAll('.widget').forEach(w => w.remove());
    document.querySelectorAll('.shape-widget').forEach(w => w.remove());
    saveBoard(); closeModal();
}
function openHelpModal() { document.getElementById('help-modal-overlay').style.display = 'flex'; }
function closeHelpModal() { document.getElementById('help-modal-overlay').style.display = 'none'; }

// =========================================================================
// HORLOGE / DATE
// =========================================================================
function updateClock() {
    const now = new Date();
    const dateStr = now.toLocaleDateString('fr-FR', { weekday:'long', day:'numeric', month:'long' });
    const timeStr = now.toLocaleTimeString('fr-FR', { hour:'2-digit', minute:'2-digit' });
    document.querySelectorAll('.agenda-current-date').forEach(el => el.textContent = dateStr);
    document.querySelectorAll('.agenda-current-time').forEach(el => el.textContent = timeStr);
    updateDateTime();
}
function updateDateTime() {
    const now = new Date();
    const days   = ['dimanche','lundi','mardi','mercredi','jeudi','vendredi','samedi'];
    const months = ['janvier','f√©vrier','mars','avril','mai','juin','juillet','ao√ªt','septembre','octobre','novembre','d√©cembre'];
    document.querySelectorAll('.calendar-day-name').forEach(el   => el.textContent = days[now.getDay()]);
    document.querySelectorAll('.calendar-day-number').forEach(el => el.textContent = now.getDate());
    document.querySelectorAll('.calendar-month').forEach(el      => el.textContent = months[now.getMonth()]);
    const hh = String(now.getHours()).padStart(2,'0'), mm = String(now.getMinutes()).padStart(2,'0'), ss = String(now.getSeconds()).padStart(2,'0');
    document.querySelectorAll('.clock-hm').forEach(el      => el.textContent = `${hh}:${mm}`);
    document.querySelectorAll('.clock-seconds').forEach(el => el.textContent = ss);
}

// =========================================================================
// WIDGETS
// =========================================================================
let widgetZCounter = 1000;
let pinnedZCounter = 10000;

function bringToFront(widget, pin = false) {
    if (pin) {
        pinnedZCounter++;
        widget.style.zIndex = pinnedZCounter;
        widget.dataset.pinned = "true";
        widget.classList.add('pinned');
    } else {
        if (widget.dataset.pinned === "true") return;
        if (widget.dataset.background === "true") return;
        widgetZCounter++;
        widget.style.zIndex = widgetZCounter;
    }
}

function togglePin(widget) {
    snapshotNow();
    if (widget.dataset.pinned === "true") {
        widget.dataset.pinned = "false";
        widget.classList.remove('pinned');
        widgetZCounter++;
        widget.style.zIndex = widgetZCounter;
    } else {
        widget.dataset.background = "false";
        bringToFront(widget, true);
    }
    saveBoard();
}

function sendToBack(widget) {
    snapshotNow();
    widget.style.zIndex = 1;
    widget.dataset.pinned = "false";
    widget.classList.remove('pinned');
    widget.dataset.background = "true";
    saveBoard();
}

// =========================================================================
// MENU CONTEXTUEL
// =========================================================================
function closeCtxMenuAll() {
    document.querySelectorAll('.widget-ctx-menu.open').forEach(m => m.classList.remove('open'));
}

document.addEventListener('mousedown', (e) => {
    if (!e.target.closest('.widget-ctx-menu') && !e.target.closest('.widget-menu-handle')) closeCtxMenuAll();
    if (!e.target.closest('#shape-edit-panel') && !e.target.closest('.shape-widget')) closeShapeEditPanel();
    if (!e.target.closest('#sc-ctx-menu') && !e.target.closest('#sc-menu-btn')) {
        const m = document.getElementById('sc-ctx-menu');
        if (m) m.classList.remove('open');
    }
});

function toggleCtxMenu(btn) {
    const widget = btn.closest('.widget, .shape-widget');
    const menu   = widget.querySelector('.widget-ctx-menu');
    if (!menu) return;
    const wasOpen = menu.classList.contains('open');
    closeCtxMenuAll();
    if (wasOpen) return;
    buildCtxMenu(menu, widget);
    menu.classList.add('open');
}

function buildCtxMenu(menu, widget) {
    const isShape = widget.classList.contains('shape-widget');
    menu.innerHTML = '';

    addCtxBtn(menu, '‚ßâ Dupliquer', () => {
        closeCtxMenuAll();
        if (isShape) cloneShapeWidget(widget);
        else cloneWidget(widget);
    });

    if (isShape) {
        addCtxBtn(menu, 'üé® Modifier', () => {
            closeCtxMenuAll();
            openShapeEditPanel(widget);
        });
    }
}

function addCtxBtn(menu, label, fn) {
    const btn = document.createElement('button');
    btn.innerHTML = label;
    btn.addEventListener('mousedown', (e) => { e.stopPropagation(); });
    btn.addEventListener('click', fn);
    menu.appendChild(btn);
}

function findFreePosition() {
    const curW = window.innerWidth, curVH = virtualH(curW);
    const occupied = Array.from(document.querySelectorAll('.widget, .shape-widget')).map(w => ({
        left: w.offsetLeft, top: w.offsetTop, right: w.offsetLeft + w.offsetWidth, bottom: w.offsetTop + w.offsetHeight
    }));
    for (let y = 20; y < curVH - 200; y += 200) {
        for (let x = 20; x < curW - 320; x += 320) {
            const overlaps = occupied.some(r => x < r.right+20 && x+320 > r.left && y < r.bottom+20 && y+180 > r.top);
            if (!overlaps) return { x, y };
        }
    }
    const count = document.querySelectorAll('.widget, .shape-widget').length;
    return { x: (20 + count * 30) % (curW - 200), y: (20 + count * 30) % (curVH - 200) };
}

function createWidget(type, x = null, y = null, doSnapshot = true) {
    if (x === null || y === null) { const p = findFreePosition(); x = p.x + 'px'; y = p.y + 'px'; }
    if (doSnapshot && !isInitialLoading && !isRestoringState) snapshotNow();
    const widget = document.createElement('div');
    widget.className = 'widget';
    widget.dataset.type = type;
    widget.style.left = x; widget.style.top = y;
    widget.tabIndex = 0;
    widget.addEventListener('mousedown', (e) => {
        if (isDrawMode || isEraserMode) return;
        if (widget.dataset.background !== "true") bringToFront(widget);
    });
    widget.innerHTML = `
        <div class="drag-handle" title="D√©placer">‚ú•</div>
        <div class="widget-rotate-handle" title="Faire pivoter">‚Üª</div>
        <div class="widget-pin-handle" onclick="togglePin(this.closest('.widget, .shape-widget'))" title="√âpingler">üìå</div>
        <div class="widget-back-handle" onclick="sendToBack(this.closest('.widget, .shape-widget'))" title="Envoyer derri√®re">üîΩ</div>
        <div class="widget-menu-handle" onclick="toggleCtxMenu(this)" title="Menu">‚ò∞</div>
        <div class="widget-close-handle" onclick="snapshotNow();closeCtxMenuAll();this.closest('.widget').remove();saveBoard();" title="Fermer">√ó</div>
        <div class="widget-ctx-menu"></div>
        <div class="widget-content"></div>`;
    const contentZone = widget.querySelector('.widget-content');
    const tpl = document.getElementById(`template-${type}`);
    if (tpl && tpl.content) {
        contentZone.appendChild(tpl.content.cloneNode(true));
    } else {
        contentZone.innerHTML = `<div style="padding:10px;color:#b00;font-size:12px;">Type inconnu : <code>${type}</code></div>`;
    }
    board.appendChild(widget);
    makeDraggable(widget);
    makeDraggableRotate(widget);
    if (type === 'agenda') { updateClock(); widget.querySelectorAll('.agenda-item').forEach(attachAgendaItemEvents); }
    const editor = widget.querySelector('.editor-content');
    if (editor) {
        editor.addEventListener('mouseup', () => syncFontSize(widget));
        editor.addEventListener('keyup',   () => syncFontSize(widget));
    }
    const REF_W = 1920, factor = window.innerWidth / REF_W;
    if (Math.abs(factor - 1) > 0.01) {
        scaleFontSizesBy(widget, factor);
        const c = widget.querySelector('.editor-container');
        if (c?.style.width)  c.style.width  = (parseFloat(c.style.width)  * factor) + 'px';
        if (c?.style.height) c.style.height = (parseFloat(c.style.height) * factor) + 'px';
    }
    if (!isInitialLoading && !isRestoringState) saveBoard();
    return widget;
}

function attachAgendaItemEvents(item) {
    item.querySelectorAll('[contenteditable="true"]').forEach(el => {
        el.addEventListener('mouseenter', () => item.draggable = false);
        el.addEventListener('mouseleave', () => item.draggable = true);
        el.addEventListener('input', saveBoard);
    });
    item.addEventListener('dragstart', handleRowDragStart);
    item.addEventListener('dragover',  handleRowDragOver);
    item.addEventListener('dragend',   handleRowDragEnd);
}

function syncFontSize(widget) {
    const toolbar = widget.querySelector('.editor-toolbar'); if (!toolbar) return;
    const sizeInput = toolbar.querySelector('input[type="number"]');
    if (!sizeInput) return;
    const sel = window.getSelection();
    if (sel.rangeCount > 0) {
        const size = window.getComputedStyle(sel.anchorNode.parentElement).fontSize;
        if (size) sizeInput.value = parseInt(size);
    }
}

function makeDraggable(elmnt) {
    const handle = elmnt.querySelector('.drag-handle');
    if (!handle) return;
    handle.onmousedown = (e) => {
        e.preventDefault();
        elmnt.dataset.background = "false";
        bringToFront(elmnt);
        snapshotNow();
        clearSelection();
        let px = e.clientX, py = e.clientY;
        document.onmousemove = (e) => {
            elmnt.style.top  = (elmnt.offsetTop  + e.clientY - py) + "px";
            elmnt.style.left = (elmnt.offsetLeft + e.clientX - px) + "px";
            px = e.clientX; py = e.clientY;
        };
        document.onmouseup = () => {
            document.onmousemove = null;
            const curW = window.innerWidth, curVH = virtualH(curW);
            elmnt.dataset.leftPercent = (elmnt.offsetLeft / curW) * 100;
            elmnt.dataset.topPercent  = (elmnt.offsetTop  / curVH) * 100;
            saveBoard();
        };
    };
}

function makeDraggableRotate(elmnt) {
    const handle = elmnt.querySelector('.widget-rotate-handle'); if (!handle) return;

    handle.ondblclick = (e) => {
        e.preventDefault(); e.stopPropagation();
        snapshotNow();
        elmnt.style.transform = '';
        hideRotationIndicator();
        saveBoard();
    };

    handle.onmousedown = (e) => {
        e.preventDefault(); e.stopPropagation();
        bringToFront(elmnt);
        snapshotNow();
        const rect = elmnt.getBoundingClientRect();
        const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
        const startAngle = Math.atan2(e.clientY - cy, e.clientX - cx);
        const startRot   = getCurrentRotation(elmnt);
        const indicator  = document.getElementById('rotation-indicator');
        document.onmousemove = (ev) => {
            const newRot = startRot + (Math.atan2(ev.clientY - cy, ev.clientX - cx) - startAngle) * 180 / Math.PI;
            const snapped = snapRotation(newRot);
            elmnt.style.transform = `rotate(${snapped}deg)`;
            if (indicator) {
                const deg = Math.round(((snapped % 360) + 360) % 360);
                document.getElementById('rot-deg').textContent = deg + '¬∞';
                indicator.style.display = 'block';
                indicator.style.left = ev.clientX + 'px';
                indicator.style.top  = ev.clientY + 'px';
                indicator.querySelector('.rot-reset-hint').style.display = (deg === 0) ? 'none' : 'inline';
            }
        };
        document.onmouseup = () => {
            document.onmousemove = null;
            hideRotationIndicator();
            saveBoard();
        };
    };
}

function snapRotation(deg) {
    const snaps = [0, 45, 90, 135, 180, 225, 270, 315, 360];
    const norm = ((deg % 360) + 360) % 360;
    for (const s of snaps) {
        const diff = Math.abs(norm - s);
        if (diff < 2) return s === 360 ? 0 : s;
    }
    return deg;
}

function hideRotationIndicator() {
    const ind = document.getElementById('rotation-indicator');
    if (ind) ind.style.display = 'none';
}

function cloneWidget(widget) {
    snapshotNow();
    const newWidget = createWidget(widget.dataset.type, (widget.offsetLeft + 30) + 'px', (widget.offsetTop + 30) + 'px', false);
    const sc = widget.querySelector('.editor-container'), dc = newWidget.querySelector('.editor-container');
    if (sc && dc) { dc.style.width = sc.style.width || sc.offsetWidth + 'px'; dc.style.height = sc.style.height || sc.offsetHeight + 'px'; }
    const se = widget.querySelector('.editor-content'), de = newWidget.querySelector('.editor-content');
    if (se && de) de.innerHTML = se.innerHTML;
    const sa = widget.querySelector('.agenda-list'), da = newWidget.querySelector('.agenda-list');
    if (sa && da) { da.innerHTML = sa.innerHTML; da.querySelectorAll('.agenda-item').forEach(attachAgendaItemEvents); }
    const si = widget.querySelector('iframe'), di = newWidget.querySelector('iframe');
    if (si && di) di.src = si.src;
    const rot = getCurrentRotation(widget);
    if (rot) newWidget.style.transform = `rotate(${rot}deg)`;
    if (widget.dataset.transparent === "true") applyTransparency(newWidget, true);
    else if (widget.dataset.bgColor) { newWidget.dataset.bgColor = widget.dataset.bgColor; newWidget.style.background = widget.dataset.bgColor; }
    saveBoard();
}

function getCurrentRotation(widget) {
    const m = widget.style.transform?.match(/rotate\(([-\d.]+)deg\)/);
    return m ? parseFloat(m[1]) : 0;
}

// =========================================================================
// FORMES G√âOM√âTRIQUES
// =========================================================================
const SHAPES = [
    { id: 'circle',        label: 'Cercle',         svg: (w,h,sw,f,o) => `<ellipse cx="${w/2}" cy="${h/2}" rx="${w/2-sw/2}" ry="${h/2-sw/2}" stroke="${sw}" stroke-width="${sw}" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'square',        label: 'Carr√©',           svg: (w,h,sw,f,o) => `<rect x="${sw/2}" y="${sw/2}" width="${w-sw}" height="${h-sw}" stroke="${sw}" stroke-width="${sw}" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'rectangle',     label: 'Rectangle',       svg: (w,h,sw,f,o) => `<rect x="${sw/2}" y="${sw/2}" width="${w-sw}" height="${h-sw}" stroke="${sw}" stroke-width="${sw}" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'diamond',       label: 'Losange',         svg: (w,h,sw,f,o) => `<polygon points="${w/2},${sw} ${w-sw},${h/2} ${w/2},${h-sw} ${sw},${h/2}" stroke="${sw}" stroke-width="${sw}" stroke-linejoin="round" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'parallelogram', label: 'Parall√©logramme', svg: (w,h,sw,f,o) => `<polygon points="${w*0.25},${sw} ${w-sw},${sw} ${w*0.75},${h-sw} ${sw},${h-sw}" stroke="${sw}" stroke-width="${sw}" stroke-linejoin="round" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'line',          label: 'Ligne',           svg: (w,h,sw,f,o) => `<line x1="${sw}" y1="${h/2}" x2="${w-sw}" y2="${h/2}" stroke="STROKECOLOR" stroke-width="${sw}" stroke-linecap="round"/>` },
    { id: 'arrow',         label: 'Fl√®che',          svg: (w,h,sw,f,o) => `<polygon points="${sw},${h*0.35} ${w*0.6},${h*0.35} ${w*0.6},${sw} ${w-sw},${h/2} ${w*0.6},${h-sw} ${w*0.6},${h*0.65} ${sw},${h*0.65}" stroke="${sw}" stroke-width="${sw}" stroke-linejoin="round" fill="${f}" fill-opacity="${o}"/>` },
    { id: 'triangle',      label: 'Triangle',        svg: (w,h,sw,f,o) => `<polygon points="${w/2},${sw} ${w-sw},${h-sw} ${sw},${h-sw}" stroke="${sw}" stroke-width="${sw}" stroke-linejoin="round" fill="${f}" fill-opacity="${o}"/>` },
];

let selectedShapeId = 'circle';

function buildShapeSVG(shapeId, w, h, strokeColor, fillColor, fillOpacity, strokeWidth) {
    const sw = strokeWidth || 4;
    const shape = SHAPES.find(s => s.id === shapeId);
    if (!shape) return '';
    let raw = shape.svg(w, h, sw, fillColor, fillOpacity);
    raw = raw.replace(/stroke="(\d+(?:\.\d+)?)"/g, `stroke="${strokeColor}"`);
    raw = raw.replace(/stroke="STROKECOLOR"/g, `stroke="${strokeColor}"`);
    return raw;
}

function initShapeToolbar() {
    const grid = document.getElementById('shape-grid');
    if (!grid) return;
    SHAPES.forEach(s => {
        const btn = document.createElement('div');
        btn.className = 'shape-choice' + (s.id === selectedShapeId ? ' active' : '');
        btn.dataset.id = s.id;
        btn.title = s.label;
        const previewSVG = `<svg width="28" height="28" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">${buildShapeSVG(s.id, 40, 40, '#ffffff', '#ffffff', 0.5)}</svg>`;
        btn.innerHTML = previewSVG + `<span class="shape-choice-label">${s.label}</span>`;
        btn.addEventListener('click', () => {
            document.querySelectorAll('.shape-choice').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            selectedShapeId = s.id;
        });
        grid.appendChild(btn);
    });
    document.getElementById('shape-opacity-slider').addEventListener('input', function() {
        document.getElementById('shape-opacity-val').textContent = this.value + '%';
    });
    document.getElementById('shape-stroke-width').addEventListener('input', function() {
        document.getElementById('shape-stroke-width-val').textContent = this.value;
    });
}

let editingShapeWidget = null;

function openShapeEditPanel(widget) {
    editingShapeWidget = widget;
    const panel = document.getElementById('shape-edit-panel');
    document.getElementById('edit-stroke-color').value = widget.dataset.strokeColor || '#2c3e50';
    document.getElementById('edit-fill-color').value   = widget.dataset.fillColor   || '#4a90e2';
    const opPct = Math.round(parseFloat(widget.dataset.fillOpacity || 0.6) * 100);
    document.getElementById('edit-fill-opacity').value = opPct;
    document.getElementById('edit-fill-opacity-val').textContent = opPct + '%';
    const sw = parseInt(widget.dataset.strokeWidth || 4);
    document.getElementById('edit-stroke-width').value = sw;
    document.getElementById('edit-stroke-width-val').textContent = sw + 'px';
    const br = widget.getBoundingClientRect();
    panel.style.left = Math.min(br.right + 10, window.innerWidth - 320) + 'px';
    panel.style.top  = Math.max(10, br.top) + 'px';
    panel.style.display = 'block';
}

function closeShapeEditPanel() {
    const panel = document.getElementById('shape-edit-panel');
    if (panel) panel.style.display = 'none';
    editingShapeWidget = null;
}

function applyShapeEdit() {
    if (!editingShapeWidget) return;
    const sc = document.getElementById('edit-stroke-color').value;
    const fc = document.getElementById('edit-fill-color').value;
    const fo = parseFloat(document.getElementById('edit-fill-opacity').value) / 100;
    const sw = parseInt(document.getElementById('edit-stroke-width').value);
    const svg = editingShapeWidget.querySelector('svg');
    if (!svg) return;
    const w = parseFloat(svg.getAttribute('width'));
    const h = parseFloat(svg.getAttribute('height'));
    editingShapeWidget.dataset.strokeColor = sc;
    editingShapeWidget.dataset.fillColor   = fc;
    editingShapeWidget.dataset.fillOpacity = fo;
    editingShapeWidget.dataset.strokeWidth = sw;
    svg.innerHTML = buildShapeSVG(editingShapeWidget.dataset.shapeType, w, h, sc, fc, fo, sw);
    saveBoard();
}

function cloneShapeWidget(widget) {
    snapshotNow();
    const svg = widget.querySelector('svg');
    const sw = parseFloat(svg.getAttribute('width') || 150);
    const sh = parseFloat(svg.getAttribute('height') || 150);
    const newW = createShapeWidget(
        widget.dataset.shapeType, widget.dataset.strokeColor, widget.dataset.fillColor,
        parseFloat(widget.dataset.fillOpacity), sw, sh,
        (widget.offsetLeft + 30) + 'px', (widget.offsetTop + 30) + 'px', true,
        parseInt(widget.dataset.strokeWidth || 4)
    );
    const rot = getCurrentRotation(widget);
    if (rot) newW.style.transform = `rotate(${rot}deg)`;
}

function toggleShapeToolbar() {
    const tb = document.getElementById('shape-toolbar');
    const btn = document.getElementById('shape-btn');
    const isActive = tb.classList.toggle('active');
    btn.style.background = isActive ? '#e6d8ff' : '#eeeeee';
    if (isActive) {
        stopDrawing();
        document.getElementById('global-toolbar').style.display = 'none';
        document.getElementById('tools-menu').classList.remove('active');
    }
}

function addShapeWidget() {
    const strokeColor = document.getElementById('shape-stroke-color').value;
    const fillColor   = document.getElementById('shape-fill-color').value;
    const fillOpacity = parseFloat(document.getElementById('shape-opacity-slider').value) / 100;
    const strokeWidth = parseInt(document.getElementById('shape-stroke-width').value);
    snapshotNow();
    const p = findFreePosition();
    const isLine = (selectedShapeId === 'line');
    const defaultW = isLine ? Math.min(window.innerWidth * 0.18, 280) : Math.min(window.innerWidth * 0.12, 180);
    const defaultH = isLine ? 20 : defaultW;
    createShapeWidget(selectedShapeId, strokeColor, fillColor, fillOpacity, defaultW, defaultH, p.x + 'px', p.y + 'px', true, strokeWidth);
    document.getElementById('shape-toolbar').classList.remove('active');
    document.getElementById('shape-btn').style.background = '#eeeeee';
}

function createShapeWidget(shapeId, strokeColor, fillColor, fillOpacity, svgW, svgH, x, y, doSave = true, strokeWidth = 4) {
    const widget = document.createElement('div');
    widget.className = 'shape-widget';
    widget.dataset.shapeType   = shapeId;
    widget.dataset.strokeColor = strokeColor;
    widget.dataset.fillColor   = fillColor;
    widget.dataset.fillOpacity = fillOpacity;
    widget.dataset.strokeWidth = strokeWidth;
    widget.style.left = x; widget.style.top = y;
    widget.tabIndex = 0;
    widgetZCounter++;
    widget.style.zIndex = widgetZCounter;

    const svgContent = buildShapeSVG(shapeId, svgW, svgH, strokeColor, fillColor, fillOpacity, strokeWidth);

    widget.innerHTML = `
        <div class="drag-handle" title="D√©placer">‚ú•</div>
        <div class="widget-rotate-handle" title="Faire pivoter">‚Üª</div>
        <div class="widget-pin-handle" onclick="togglePin(this.closest('.widget, .shape-widget'))" title="√âpingler">üìå</div>
        <div class="widget-back-handle" onclick="sendToBack(this.closest('.widget, .shape-widget'))" title="Envoyer derri√®re">üîΩ</div>
        <div class="widget-menu-handle" onclick="toggleCtxMenu(this)" title="Menu">‚ò∞</div>
        <div class="widget-close-handle" onclick="snapshotNow();closeCtxMenuAll();this.closest('.shape-widget').remove();saveBoard();" title="Fermer">√ó</div>
        <div class="widget-ctx-menu"></div>
        <div class="shape-svg-wrap">
            <svg xmlns="http://www.w3.org/2000/svg" width="${svgW}" height="${svgH}" viewBox="0 0 ${svgW} ${svgH}" style="overflow:visible;">${svgContent}</svg>
        </div>
        <div class="flip-h-btn" title="Sym√©trie horizontale">‚Üî</div>
        <div class="flip-v-btn" title="Sym√©trie verticale">‚Üï</div>
        <div class="resize-lock-btn" title="Verrouiller les proportions (ou Shift)">üîì</div>
        <div class="shape-resize-handle" title="Redimensionner"></div>
    `;

    board.appendChild(widget);
    makeDraggable(widget);
    makeDraggableRotate(widget);
    makeShapeResizable(widget);

    widget.addEventListener('mousedown', (e) => {
        if (isDrawMode || isEraserMode) return;
        if (widget.dataset.background !== "true") bringToFront(widget);
    });
    widget.addEventListener('dblclick', (e) => {
        const ignore = '.drag-handle,.widget-close-handle,.widget-pin-handle,.widget-back-handle,.widget-rotate-handle,.widget-menu-handle,.widget-ctx-menu,.shape-resize-handle';
        if (!e.target.closest(ignore)) openShapeEditPanel(widget);
    });

    const curW = window.innerWidth, curVH = virtualH(curW);
    widget.dataset.leftPercent = (parseFloat(x) / curW) * 100;
    widget.dataset.topPercent  = (parseFloat(y) / curVH) * 100;
    widget.dataset.wPercent    = (svgW / curW) * 100;
    widget.dataset.hPercent    = (svgH / curVH) * 100;

    if (doSave && !isInitialLoading && !isRestoringState) saveBoard();
    return widget;
}

function makeShapeResizable(widget) {
    const handle  = widget.querySelector('.shape-resize-handle');
    const lockBtn = widget.querySelector('.resize-lock-btn');
    const flipH   = widget.querySelector('.flip-h-btn');
    const flipV   = widget.querySelector('.flip-v-btn');
    if (!handle) return;

    if (lockBtn) {
        lockBtn.addEventListener('mousedown', (e) => { e.preventDefault(); e.stopPropagation(); });
        lockBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const locked = lockBtn.classList.toggle('locked');
            lockBtn.textContent = locked ? 'üîí' : 'üîì';
        });
    }
    if (flipH) {
        flipH.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); });
        flipH.addEventListener('click', e => { e.stopPropagation(); snapshotNow(); flipWidget(widget, 'h'); });
    }
    if (flipV) {
        flipV.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); });
        flipV.addEventListener('click', e => { e.stopPropagation(); snapshotNow(); flipWidget(widget, 'v'); });
    }

    handle.addEventListener('mousedown', (e) => {
        e.preventDefault(); e.stopPropagation();
        snapshotNow();
        const svg = widget.querySelector('svg');
        const startX = e.clientX, startY = e.clientY;
        const startW = parseFloat(svg.getAttribute('width'));
        const startH = parseFloat(svg.getAttribute('height'));
        const ratio = startH / startW;
        const shapeId = widget.dataset.shapeType;
        const sc = widget.dataset.strokeColor, fc = widget.dataset.fillColor;
        const fo = widget.dataset.fillOpacity, sw = parseInt(widget.dataset.strokeWidth || 4);
        document.onmousemove = (ev) => {
            const proportional = ev.shiftKey || (lockBtn && lockBtn.classList.contains('locked'));
            const rawW = Math.max(40, startW + ev.clientX - startX);
            const rawH = Math.max(40, startH + ev.clientY - startY);
            let newW, newH;
            if (proportional) {
                newW = rawW;
                newH = Math.max(40, newW * ratio);
            } else {
                newW = rawW; newH = rawH;
            }
            svg.setAttribute('width', newW); svg.setAttribute('height', newH);
            svg.setAttribute('viewBox', `0 0 ${newW} ${newH}`);
            svg.innerHTML = buildShapeSVG(shapeId, newW, newH, sc, fc, fo, sw);
            const curW = window.innerWidth, curVH = virtualH(curW);
            widget.dataset.wPercent = (newW / curW) * 100;
            widget.dataset.hPercent = (newH / curVH) * 100;
        };
        document.onmouseup = () => { document.onmousemove = null; saveBoard(); };
    });
}

// Applique une sym√©trie √† un widget forme ou texte
// axis : 'h' (retournement gauche/droite) ou 'v' (retournement haut/bas)
function flipWidget(widget, axis) {
    // Extraire la rotation existante (rotation seule sur le widget)
    const rotMatch = (widget.style.transform || '').match(/rotate\(([-\d.]+)deg\)/);
    const rot = rotMatch ? parseFloat(rotMatch[1]) : 0;

    // Mettre √† jour les donn√©es de flip
    let sx = parseFloat(widget.dataset.flipX || 1);
    let sy = parseFloat(widget.dataset.flipY || 1);
    if (axis === 'h') sx = -sx;
    if (axis === 'v') sy = -sy;
    widget.dataset.flipX = sx;
    widget.dataset.flipY = sy;

    // Le widget ne porte QUE la rotation ‚Äî les boutons restent √† leur place
    widget.style.transform = rot !== 0 ? `rotate(${rot}deg)` : '';

    // Le flip est appliqu√© sur le SVG uniquement via CSS (transform-origin: center)
    const svg = widget.querySelector('svg');
    if (svg) {
        svg.style.transformBox    = 'fill-box';
        svg.style.transformOrigin = 'center center';
        svg.style.transform       = (sx !== 1 || sy !== 1) ? `scale(${sx}, ${sy})` : '';
        svg.removeAttribute('transform'); // nettoyer l'ancien attribut SVG si pr√©sent
    } else {
        // Widget texte : flip sur le container interne
        const container = widget.querySelector('.editor-container');
        if (container) {
            container.style.transformBox    = 'border-box';
            container.style.transformOrigin = 'center center';
            container.style.transform       = (sx !== 1 || sy !== 1) ? `scale(${sx}, ${sy})` : '';
        }
    }
    saveBoard();
}

// Applique une sym√©trie aux traits canvas s√©lectionn√©s
// axis : 'h' ou 'v' ‚Äî miroir autour du centre de leur bounding box
function flipStrokes(strokesList, axis) {
    if (!strokesList.length) return;
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    strokesList.forEach(s => s.points.forEach(p => {
        if (p.x < minX) minX = p.x; if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x; if (p.y > maxY) maxY = p.y;
    }));
    const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;
    strokesList.forEach(s => {
        s.points = s.points.map(p => ({
            x: axis === 'h' ? 2 * cx - p.x : p.x,
            y: axis === 'v' ? 2 * cy - p.y : p.y
        }));
    });
    if (drawCtx) redrawStrokes();
}

// =========================================================================
// PDF WIDGET
// =========================================================================
function loadPdfWidget(input) {
    const file = input.files[0]; if (!file) return;
    const url = URL.createObjectURL(file);
    const embed = input.closest('.editor-container').querySelector('embed');
    embed.src = url;
}

// =========================================================================
// DESSIN LIBRE
// =========================================================================
let drawCanvas = null, drawCtx = null, isPainting = false, isDrawMode = false;
let strokes = [], currentStroke = null;

function initCanvas() {
    if (drawCanvas) return;
    drawCanvas = document.createElement('canvas');
    drawCanvas.id = 'draw-canvas';
    resizeCanvas();
    board.appendChild(drawCanvas);
    drawCtx = drawCanvas.getContext('2d');
    drawCanvas.addEventListener('mousedown',  startPaint);
    drawCanvas.addEventListener('mousemove',  paint);
    drawCanvas.addEventListener('mouseup',    endPaint);
    drawCanvas.addEventListener('mouseleave', endPaint);
    drawCanvas.addEventListener('touchstart', e => { e.preventDefault(); startPaint(e.touches[0]); }, { passive:false });
    drawCanvas.addEventListener('touchmove',  e => { e.preventDefault(); paint(e.touches[0]); }, { passive:false });
    drawCanvas.addEventListener('touchend',   endPaint);
    document.getElementById('draw-size').addEventListener('input', function() {
        document.getElementById('draw-size-label').textContent = this.value;
    });
    const opSlider = document.getElementById('shape-recog-opacity');
    if (opSlider) opSlider.addEventListener('input', function() {
        document.getElementById('shape-recog-opacity-val').textContent = this.value + '%';
    });
}

function resizeCanvas() {
    if (!drawCanvas) return;
    drawCanvas.width = board.offsetWidth; drawCanvas.height = board.offsetHeight;
    redrawStrokes();
}

function getPos(e) {
    const rect = drawCanvas.getBoundingClientRect();
    const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
    const clientY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
}

function startPaint(e) {
    if (!isDrawMode || isEraserMode) return;
    isPainting = true;
    currentStroke = { points:[getPos(e)], color:document.getElementById('draw-color').value, size:parseInt(document.getElementById('draw-size').value) };
    if (currentDrawMode === 'shape') _lastStrokePoints = [...currentStroke.points];
}
function paint(e) {
    if (!isPainting || !isDrawMode || isEraserMode || !currentStroke) return;
    currentStroke.points.push(getPos(e));
    if (currentDrawMode === 'shape') _lastStrokePoints = [...currentStroke.points];
    redrawStrokes(currentStroke);
}
function endPaint() {
    if (!isPainting || !currentStroke) return;
    isPainting = false;
    if (currentStroke.points.length > 1) {
        if (currentDrawMode === 'shape') {
            // Try shape recognition ‚Äî it handles saving itself
            currentStroke = null;
            redrawStrokes();
            recognizeAndReplaceShape({ points: _lastStrokePoints, color: document.getElementById('draw-color').value, size: parseInt(document.getElementById('draw-size').value) });
            _lastStrokePoints = null;
            return;
        }
        strokes.push(currentStroke);
        // Pousser directement dans la pile ‚Äî 1 undo par trait dessin√©
        const cur = buildBoardJSON();
        if (cur) {
            undoStack.push(cur);
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack = [];
            updateUndoRedoBtns();
        }
        saveBoard();
    }
    currentStroke = null; redrawStrokes();
}
let _lastStrokePoints = null;

function redrawStrokes(extra = null) {
    if (!drawCtx) return;
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    strokes.forEach(s => drawStroke(s));
    if (extra) drawStroke(extra);
    selectedStrokes.forEach(s => drawStroke(s, true));
}

function drawStroke(stroke, highlight = false) {
    if (!stroke.points || stroke.points.length < 2) return;
    drawCtx.save();
    drawCtx.beginPath(); drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
    drawCtx.strokeStyle = highlight ? '#4a90e2' : stroke.color;
    drawCtx.lineWidth   = highlight ? stroke.size + 6 : stroke.size;
    if (highlight) drawCtx.globalAlpha = 0.5;
    drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
    stroke.points.forEach(p => drawCtx.lineTo(p.x, p.y));
    drawCtx.stroke(); drawCtx.restore();
    if (highlight) {
        drawCtx.save(); drawCtx.beginPath(); drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round';
        drawCtx.strokeStyle = stroke.color; drawCtx.lineWidth = stroke.size;
        drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
        stroke.points.forEach(p => drawCtx.lineTo(p.x, p.y));
        drawCtx.stroke(); drawCtx.restore();
    }
}

// =========================================================================
// MODES DESSIN
// =========================================================================
let currentDrawMode = 'free'; // 'free' | 'shape' | 'text'

function setDrawMode(mode) {
    currentDrawMode = mode;
    // Update buttons style
    ['free','shape','text'].forEach(m => {
        const btn = document.getElementById('draw-mode-'+m+'-btn');
        if (!btn) return;
        if (m === mode) {
            btn.style.borderColor = '#4a90e2'; btn.style.background = '#1a3550'; btn.style.color = '#fff';
        } else {
            btn.style.borderColor = '#444'; btn.style.background = '#2a2a2e'; btn.style.color = '#aaa';
        }
    });
    // Show/hide shape-specific options
    const shapeOpts = document.getElementById('shape-recog-options');
    const shapeHint = document.getElementById('shape-recog-hint');
    if (mode === 'shape') {
        shapeOpts.style.display = 'flex'; shapeHint.style.display = 'block';
    } else {
        shapeOpts.style.display = 'none'; shapeHint.style.display = 'none';
    }
    if (mode === 'text') {
        // Future : √©criture manuscrite
        alert('‚úçÔ∏è La reconnaissance d\'√©criture manuscrite sera disponible prochainement !');
        setDrawMode('free'); return;
    }
}

function toggleDrawToolbar() {
    const tb = document.getElementById('draw-toolbar');
    if (tb.style.display === 'flex') { stopDrawing(); return; }
    stopEraserMode();
    document.getElementById('shape-toolbar').classList.remove('active');
    document.getElementById('shape-btn').style.background = '#eeeeee';
    tb.style.display = 'flex';
    initCanvas(); enableDrawing();
    setDrawMode('free'); // always start in free mode
}
function enableDrawing() {
    isDrawMode = true; drawCanvas.classList.remove('inactive');
    document.getElementById('draw-btn').style.background = '#e6b8de';
    document.getElementById('draw-btn').textContent = '‚úèÔ∏è';
    clearSelection();
}
function stopDrawing() {
    isDrawMode = false;
    if (drawCanvas) drawCanvas.classList.add('inactive');
    document.getElementById('draw-toolbar').style.display = 'none';
    document.getElementById('draw-btn').style.background = '#eeeeee';
    document.getElementById('draw-btn').textContent = '‚úèÔ∏è';
}
function clearCanvas() {
    snapshotNow();
    strokes = []; selectedStrokes = []; redrawStrokes();
}

// =========================================================================
// RECONNAISSANCE DE FORMES
// =========================================================================

function recognizeAndReplaceShape(stroke) {
    if (!stroke || stroke.points.length < 4) return false;
    const pts = stroke.points;

    // Bounding box
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    pts.forEach(p => {
        if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y;
        if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y;
    });
    const w = maxX - minX, h = maxY - minY;
    if (w < 10 && h < 10) return false;

    const strokeColor = document.getElementById('draw-color').value;
    const strokeWidth = parseInt(document.getElementById('draw-size').value);
    const fillColor   = document.getElementById('shape-recog-fill').value;
    const fillOpacity = parseInt(document.getElementById('shape-recog-opacity').value) / 100;

    // Detect if closed (start ‚âà end)
    const firstPt = pts[0], lastPt = pts[pts.length-1];
    const closeDist = Math.hypot(firstPt.x-lastPt.x, firstPt.y-lastPt.y);
    const diagLen   = Math.hypot(w, h);
    const isClosed  = closeDist < diagLen * 0.35;

    let shapeId = null;

    if (isClosed) {
        const cx = (minX+maxX)/2, cy = (minY+maxY)/2;
        // Circle: variance of radii from centroid
        const radii  = pts.map(p => Math.hypot(p.x-cx, p.y-cy));
        const avgR   = radii.reduce((a,b)=>a+b,0)/radii.length;
        const cv     = Math.sqrt(radii.reduce((a,v)=>a+(v-avgR)**2,0)/radii.length) / avgR;
        const aspect = Math.min(w,h) / Math.max(w,h);

        if (cv < 0.20 && aspect > 0.65) {
            shapeId = 'circle';
        } else if (isLikelyTriangle(pts)) {
            shapeId = 'triangle';
        } else {
            // Rectangle vs carr√© : simplifier le trac√© pour compter les coins
            const epsilon = Math.min(w, h) * 0.08;
            const simplified = rdpSimplify(pts, epsilon);
            shapeId = (simplified.length >= 3 && simplified.length <= 7)
                ? (aspect > 0.80 ? 'square' : 'rectangle')
                : (aspect > 0.80 ? 'square' : 'rectangle');
        }
    } else {
        // Trac√© ouvert ‚Üí dessin libre classique
        strokes.push({ ...stroke, recognized: false });
        const cur = buildBoardJSON();
        if (cur) { undoStack.push(cur); if (undoStack.length > MAX_UNDO) undoStack.shift(); redoStack=[]; updateUndoRedoBtns(); }
        saveBoard();
        redrawStrokes();
        return false;
    }

    // --- Cr√©er un vrai widget SVG comme addShapeWidget() ---
    // Les coords canvas = coords board (canvas couvre exactement le board)
    const bx = minX;
    const by = minY;

    // Pour le cercle, forcer un carr√© englobant centr√©
    let svgW = w, svgH = h;
    if (shapeId === 'circle') {
        const side = Math.max(w, h);
        svgW = side; svgH = side;
    }

    // Cr√©er sans doSave pour contr√¥ler manuellement le snapshot
    createShapeWidget(
        shapeId, strokeColor, fillColor, fillOpacity,
        svgW, svgH,
        bx + 'px', by + 'px',
        false, strokeWidth
    );

    // Snapshot imm√©diat APR√àS cr√©ation (√©vite le bug undo avec scheduleSaveSnapshot)
    const snapCur = buildBoardJSON();
    if (snapCur) {
        undoStack.push(snapCur);
        if (undoStack.length > MAX_UNDO) undoStack.shift();
        redoStack = [];
        updateUndoRedoBtns();
        localStorage.setItem('profBoardConfig', snapCur);
    }
    redrawStrokes();
    return true;
}

function isLikelyTriangle(pts) {
    // Simplify and count corners ‚Äî triangle = 3 corners
    const epsilon = Math.hypot(
        Math.max(...pts.map(p=>p.x)) - Math.min(...pts.map(p=>p.x)),
        Math.max(...pts.map(p=>p.y)) - Math.min(...pts.map(p=>p.y))
    ) * 0.10;
    const simplified = rdpSimplify(pts, epsilon);
    return simplified.length >= 3 && simplified.length <= 5;
}

function rdpSimplify(pts, epsilon) {
    if (pts.length < 3) return pts;
    let maxDist = 0, maxIdx = 0;
    const first = pts[0], last = pts[pts.length-1];
    for (let i=1; i<pts.length-1; i++) {
        const d = perpendicularDist(pts[i], first, last);
        if (d > maxDist) { maxDist = d; maxIdx = i; }
    }
    if (maxDist > epsilon) {
        const left = rdpSimplify(pts.slice(0, maxIdx+1), epsilon);
        const right = rdpSimplify(pts.slice(maxIdx), epsilon);
        return [...left.slice(0,-1), ...right];
    }
    return [first, last];
}

function perpendicularDist(pt, lineA, lineB) {
    const dx = lineB.x - lineA.x, dy = lineB.y - lineA.y;
    const len = Math.hypot(dx, dy);
    if (len === 0) return Math.hypot(pt.x - lineA.x, pt.y - lineA.y);
    return Math.abs(dy*pt.x - dx*pt.y + lineB.x*lineA.y - lineB.y*lineA.x) / len;
}



// =========================================================================
// GOMME
// =========================================================================
let isEraserMode = false, isErasing = false;

function toggleEraserMode() {
    if (isEraserMode) { stopEraserMode(); return; }
    stopDrawing();
    document.getElementById('shape-toolbar').classList.remove('active');
    document.getElementById('shape-btn').style.background = '#eeeeee';
    document.getElementById('global-toolbar').style.display = 'none';
    isEraserMode = true;
    initCanvas();
    drawCanvas.classList.remove('inactive');
    drawCanvas.classList.add('eraser-mode');
    document.getElementById('eraser-btn').style.background = '#ffe0b2';
    document.getElementById('eraser-btn').textContent = 'üßπ en cours‚Ä¶';
    document.getElementById('eraser-toolbar').style.display = 'flex';
    drawCanvas.addEventListener('mousedown',  startErase);
    drawCanvas.addEventListener('mousemove',  onEraserMouseMove);
    drawCanvas.addEventListener('mouseup',    endErase);
    drawCanvas.addEventListener('mouseleave', onEraserLeave);
    drawCanvas.addEventListener('touchstart', eTouchStart, { passive: false });
    drawCanvas.addEventListener('touchmove',  eTouchMove,  { passive: false });
    drawCanvas.addEventListener('touchend',   endErase);
    clearSelection();
}

function stopEraserMode() {
    if (!isEraserMode) return;
    isEraserMode = false; isErasing = false;
    if (drawCanvas) {
        drawCanvas.classList.add('inactive');
        drawCanvas.classList.remove('eraser-mode');
        drawCanvas.removeEventListener('mousedown',  startErase);
        drawCanvas.removeEventListener('mousemove',  onEraserMouseMove);
        drawCanvas.removeEventListener('mouseup',    endErase);
        drawCanvas.removeEventListener('mouseleave', onEraserLeave);
        drawCanvas.removeEventListener('touchstart', eTouchStart);
        drawCanvas.removeEventListener('touchmove',  eTouchMove);
        drawCanvas.removeEventListener('touchend',   endErase);
        redrawStrokes();
    }
    document.getElementById('eraser-btn').style.background = '#eeeeee';
    document.getElementById('eraser-btn').textContent = 'üßπ';
    document.getElementById('eraser-toolbar').style.display = 'none';
}

function eTouchStart(e) { e.preventDefault(); snapshotNow(); isErasing = true; eraseAt(getPos(e.touches[0])); }
function eTouchMove(e)  { e.preventDefault(); if (isErasing) eraseAt(getPos(e.touches[0])); }

function onEraserMouseMove(e) {
    const pos = getPos(e);
    const r = parseInt(document.getElementById('eraser-size').value);
    if (isErasing) eraseAt(pos);
    else drawEraserPreview(pos, r);
}
function onEraserLeave() { endErase(); redrawStrokes(); }
function startErase(e) { if (!isEraserMode) return; snapshotNow(); isErasing = true; eraseAt(getPos(e)); }
function endErase() { if (!isErasing) return; isErasing = false; saveBoard(); }

// =========================================================================
// D√âTECTION FORME SVG ENTI√àREMENT GOMM√âE
// =========================================================================
function isShapeFullyErased(widget) {
    const svg = widget.querySelector('svg');
    if (!svg) return false;
    if (!svg.querySelector('mask.eraser-mask')) return false;
    const svgW = parseFloat(svg.getAttribute('width')) || 100;
    const svgH = parseFloat(svg.getAttribute('height')) || 100;
    const tmpCanvas = document.createElement('canvas');
    const scale = Math.min(1, 200 / Math.max(svgW, svgH));
    tmpCanvas.width  = Math.ceil(svgW * scale);
    tmpCanvas.height = Math.ceil(svgH * scale);
    const tmpCtx = tmpCanvas.getContext('2d');
    const svgClone = svg.cloneNode(true);
    svgClone.setAttribute('width',  tmpCanvas.width);
    svgClone.setAttribute('height', tmpCanvas.height);
    svgClone.setAttribute('viewBox', `0 0 ${svgW} ${svgH}`);
    const svgStr = new XMLSerializer().serializeToString(svgClone);
    const blob = new Blob([svgStr], { type: 'image/svg+xml' });
    const url  = URL.createObjectURL(blob);
    return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
            tmpCtx.clearRect(0, 0, tmpCanvas.width, tmpCanvas.height);
            tmpCtx.drawImage(img, 0, 0);
            URL.revokeObjectURL(url);
            const data = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
            for (let i = 3; i < data.length; i += 4) {
                if (data[i] > 5) { resolve(false); return; }
            }
            resolve(true);
        };
        img.onerror = () => { URL.revokeObjectURL(url); resolve(false); };
        img.src = url;
    });
}

async function removeFullyErasedShapes() {
    const shapeWidgets = [...document.querySelectorAll('.shape-widget')];
    const toRemove = [];
    for (const widget of shapeWidgets) {
        const erased = await isShapeFullyErased(widget);
        if (erased) toRemove.push(widget);
    }
    if (toRemove.length > 0) {
        toRemove.forEach(w => w.remove());
        saveBoard();
    }
}

function eraseAt(pos) {
    const r = parseInt(document.getElementById('eraser-size').value);
    const NS = 'http://www.w3.org/2000/svg';
    const newStrokes = [];
    strokes.forEach(stroke => {
        const pts = stroke.points;
        let current = [];
        for (let i = 0; i < pts.length; i++) {
            if (Math.hypot(pts[i].x - pos.x, pts[i].y - pos.y) <= r) {
                if (current.length >= 2) newStrokes.push({ ...stroke, points: current });
                current = [];
            } else { current.push(pts[i]); }
        }
        if (current.length >= 2) newStrokes.push({ ...stroke, points: current });
    });
    strokes = newStrokes;
    let shapesModified = false;
    document.querySelectorAll('.shape-widget').forEach(widget => {
        const svg = widget.querySelector('svg');
        if (!svg) return;
        const bRect = board.getBoundingClientRect();
        const svg2R = svg.getBoundingClientRect();
        const svgX = pos.x - (svg2R.left - bRect.left);
        const svgY = pos.y - (svg2R.top  - bRect.top);
        if (svgX < -r || svgY < -r || svgX > svg2R.width + r || svgY > svg2R.height + r) return;
        let mask = svg.querySelector('mask.eraser-mask');
        if (!mask) {
            const defs = document.createElementNS(NS, 'defs');
            mask = document.createElementNS(NS, 'mask');
            mask.setAttribute('class', 'eraser-mask');
            mask.setAttribute('id', 'em-' + Math.random().toString(36).slice(2));
            const bg = document.createElementNS(NS, 'rect');
            bg.setAttribute('x', '-500'); bg.setAttribute('y', '-500');
            bg.setAttribute('width', '9999'); bg.setAttribute('height', '9999');
            bg.setAttribute('fill', 'white');
            mask.appendChild(bg); defs.appendChild(mask);
            svg.insertBefore(defs, svg.firstChild);
            const g = document.createElementNS(NS, 'g');
            g.setAttribute('mask', 'url(#' + mask.id + ')');
            const toMove = [...svg.childNodes].filter(n => n !== defs);
            toMove.forEach(n => g.appendChild(n));
            svg.appendChild(g);
        }
        const circle = document.createElementNS(NS, 'circle');
        circle.setAttribute('cx', svgX); circle.setAttribute('cy', svgY);
        circle.setAttribute('r', r); circle.setAttribute('fill', 'black');
        mask.appendChild(circle);
        shapesModified = true;
    });
    drawEraserPreview(pos, r);
    if (shapesModified) {
        clearTimeout(eraseAt._checkTimer);
        eraseAt._checkTimer = setTimeout(() => {
            removeFullyErasedShapes();
        }, 150);
    }
}

function drawEraserPreview(pos, r) {
    if (!drawCtx) return;
    redrawStrokes();
    drawCtx.save();
    drawCtx.beginPath();
    drawCtx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
    drawCtx.strokeStyle = 'rgba(60,60,60,0.7)';
    drawCtx.lineWidth = 1.5;
    drawCtx.setLineDash([4, 3]);
    drawCtx.stroke();
    drawCtx.beginPath();
    drawCtx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
    drawCtx.fillStyle = 'rgba(60,60,60,0.5)';
    drawCtx.fill();
    drawCtx.restore();
}

// =========================================================================
// S√âLECTION
// =========================================================================
let selectedWidgets = [], selectedStrokes = [];
let selectionRect = null;
let isSelectingRect = false, selectStartX = 0, selectStartY = 0;
let mouseDownClientX = 0, mouseDownClientY = 0;
let moveStartX = 0, moveStartY = 0;
let widgetMoveOrigins = [], strokeMoveOrigins = [];
let rotateCenterX = 0, rotateCenterY = 0, rotateStartAngle = 0;
let rotateOrigWidgetTransforms = [], rotateOrigStrokePoints = [];

function initSelectionRect() {
    if (selectionRect) return;
    selectionRect = document.createElement('div');
    selectionRect.id = 'selection-rect';
    board.appendChild(selectionRect);
}

function initBoardSelection() {
    initSelectionRect();
    board.addEventListener('mousedown', onBoardMouseDown);
}

function onBoardMouseDown(e) {
    if (isDrawMode || isEraserMode) return;
    if (e.target.closest('#selection-controls')) return;
    if (e.target.closest('#toolbar-container')) return;
    if (e.target.closest('.widget-ctx-menu')) return;
    if (e.target.closest('#shape-edit-panel')) return;

    mouseDownClientX = e.clientX;
    mouseDownClientY = e.clientY;

    const widget = e.target.closest('.widget, .shape-widget');

    if (widget) {
        const gid = widget.dataset.groupId;
        // Membres DOM du groupe (widgets + shape-widgets)
        const domMembers = gid
            ? [...document.querySelectorAll(`.widget[data-group-id="${gid}"], .shape-widget[data-group-id="${gid}"]`)]
            : [widget];
        // Membres traits canvas du groupe
        const strokeMembers = gid ? strokes.filter(s => s.groupId === gid) : [];

        if (e.ctrlKey || e.metaKey) {
            const allDomSelected    = domMembers.every(m => selectedWidgets.includes(m));
            const allStrokeSel      = strokeMembers.every(s => selectedStrokes.includes(s));
            const allAlreadySelected = allDomSelected && allStrokeSel;
            if (allAlreadySelected) {
                domMembers.forEach(m => { selectedWidgets = selectedWidgets.filter(w => w !== m); m.classList.remove('selected'); });
                selectedStrokes = selectedStrokes.filter(s => !strokeMembers.includes(s));
            } else {
                domMembers.forEach(m => { if (!selectedWidgets.includes(m)) { selectedWidgets.push(m); m.classList.add('selected'); } });
                strokeMembers.forEach(s => { if (!selectedStrokes.includes(s)) selectedStrokes.push(s); });
            }
        } else {
            const allDomSelected    = domMembers.every(m => selectedWidgets.includes(m));
            const allStrokeSel      = strokeMembers.every(s => selectedStrokes.includes(s));
            const allAlreadySelected = allDomSelected && allStrokeSel
                && selectedWidgets.length === domMembers.length
                && selectedStrokes.length === strokeMembers.length;
            if (!allAlreadySelected) {
                clearSelection();
                domMembers.forEach(m => { selectedWidgets.push(m); m.classList.add('selected'); });
                strokeMembers.forEach(s => selectedStrokes.push(s));
            }
        }
        if (drawCtx) redrawStrokes();
        updateSelectionOverlay();
        return;
    }

    const pos = getBoardPos(e);

    const hitStroke = findStrokeAt(pos.x, pos.y);
    if (hitStroke) {
        const gid = hitStroke.groupId;
        const groupStrokes  = gid ? strokes.filter(s => s.groupId === gid) : [hitStroke];
        const groupWidgets  = gid
            ? [...document.querySelectorAll(`.widget[data-group-id="${gid}"], .shape-widget[data-group-id="${gid}"]`)]
            : [];

        if (e.ctrlKey || e.metaKey) {
            const allInSel = groupStrokes.every(s => selectedStrokes.includes(s))
                          && groupWidgets.every(w => selectedWidgets.includes(w));
            if (allInSel) {
                selectedStrokes = selectedStrokes.filter(s => !groupStrokes.includes(s));
                groupWidgets.forEach(w => { selectedWidgets = selectedWidgets.filter(x => x !== w); w.classList.remove('selected'); });
            } else {
                groupStrokes.forEach(s => { if (!selectedStrokes.includes(s)) selectedStrokes.push(s); });
                groupWidgets.forEach(w => { if (!selectedWidgets.includes(w)) { selectedWidgets.push(w); w.classList.add('selected'); } });
            }
        } else {
            const allInSel = groupStrokes.every(s => selectedStrokes.includes(s))
                          && groupWidgets.every(w => selectedWidgets.includes(w))
                          && selectedStrokes.length === groupStrokes.length
                          && selectedWidgets.length === groupWidgets.length;
            if (!allInSel) {
                clearSelection();
                groupStrokes.forEach(s => selectedStrokes.push(s));
                groupWidgets.forEach(w => { selectedWidgets.push(w); w.classList.add('selected'); });
            }
        }
        if (drawCtx) redrawStrokes();
        updateSelectionOverlay();
        return;
    }

    clearSelection();
    isSelectingRect = true;
    selectStartX = pos.x;
    selectStartY = pos.y;
    selectionRect.style.cssText = `display:block;left:${pos.x}px;top:${pos.y}px;width:0;height:0;`;

    const onMove = (ev) => {
        if (!isSelectingRect) return;
        const p = getBoardPos(ev);
        const x = Math.min(p.x, selectStartX), y = Math.min(p.y, selectStartY);
        Object.assign(selectionRect.style, {
            left: x+'px', top: y+'px',
            width: Math.abs(p.x - selectStartX)+'px',
            height: Math.abs(p.y - selectStartY)+'px'
        });
    };

    const onUp = (ev) => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        if (!isSelectingRect) return;
        isSelectingRect = false;

        const dx = Math.abs(ev.clientX - mouseDownClientX);
        const dy = Math.abs(ev.clientY - mouseDownClientY);

        if (dx < 5 && dy < 5) {
            clearSelection();
            return;
        }

        const pos2 = getBoardPos(ev);
        const rx = Math.min(pos2.x, selectStartX), ry = Math.min(pos2.y, selectStartY);
        const rw = Math.abs(pos2.x - selectStartX), rh = Math.abs(pos2.y - selectStartY);
        const br = board.getBoundingClientRect();

        document.querySelectorAll('.widget, .shape-widget').forEach(w => {
            const r = w.getBoundingClientRect();
            const wl = r.left - br.left, wt = r.top - br.top;
            if (wl < rx+rw && wl+r.width > rx && wt < ry+rh && wt+r.height > ry) {
                selectedWidgets.push(w);
                w.classList.add('selected');
            }
        });

        if (strokes) {
            strokes.forEach(s => {
                if (s.points.some(p => p.x >= rx && p.x <= rx+rw && p.y >= ry && p.y <= ry+rh))
                    selectedStrokes.push(s);
            });
        }

        if (drawCtx) redrawStrokes();
        updateSelectionOverlay();
        if (selectionRect) selectionRect.style.display = 'none';
    };

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
}

function clearSelection() {
    selectedWidgets.forEach(w => w.classList.remove('selected'));
    selectedWidgets = []; selectedStrokes = [];
    if (drawCtx) redrawStrokes();
    document.getElementById('selection-controls').style.display = 'none';
    if (selectionRect) selectionRect.style.display = 'none';
    board.classList.remove('single-select');
    board.classList.remove('multi-select');
}

// =========================================================================
// GROUPEMENT DE WIDGETS
// =========================================================================
let groupCounter = 0;

function mergeWidgets() {
    const totalItems = selectedWidgets.length + selectedStrokes.length;
    if (totalItems < 2) return;
    snapshotNow();
    groupCounter++;
    const groupId = 'grp-' + Date.now() + '-' + groupCounter;
    selectedWidgets.forEach(w => {
        const existingGroup = w.dataset.groupId;
        if (existingGroup && existingGroup !== groupId) {
            document.querySelectorAll(`.widget[data-group-id="${existingGroup}"], .shape-widget[data-group-id="${existingGroup}"]`).forEach(m => {
                m.dataset.groupId = groupId;
            });
            strokes.filter(s => s.groupId === existingGroup).forEach(s => { s.groupId = groupId; });
        }
        w.dataset.groupId = groupId;
    });
    selectedStrokes.forEach(s => {
        const existingGroup = s.groupId;
        if (existingGroup && existingGroup !== groupId) {
            document.querySelectorAll(`.widget[data-group-id="${existingGroup}"], .shape-widget[data-group-id="${existingGroup}"]`).forEach(m => {
                m.dataset.groupId = groupId;
            });
            strokes.filter(st => st.groupId === existingGroup).forEach(st => { st.groupId = groupId; });
        }
        s.groupId = groupId;
    });
    updateSelectionOverlay();
    saveBoard();
}

function ungroupWidgets() {
    if (selectedWidgets.length === 0 && selectedStrokes.length === 0) return;
    snapshotNow();
    const groupIds = new Set([
        ...selectedWidgets.map(w => w.dataset.groupId),
        ...selectedStrokes.map(s => s.groupId)
    ].filter(Boolean));
    groupIds.forEach(gid => {
        document.querySelectorAll(`.widget[data-group-id="${gid}"], .shape-widget[data-group-id="${gid}"]`).forEach(w => {
            delete w.dataset.groupId;
        });
        strokes.filter(s => s.groupId === gid).forEach(s => { delete s.groupId; });
    });
    clearSelection();
    saveBoard();
}

function initSelectionControls() {
    document.getElementById('sc-move-btn').onmousedown = (e) => {
        e.preventDefault(); e.stopPropagation();
        snapshotNow();
        const pos = getBoardPos(e);
        moveStartX = pos.x; moveStartY = pos.y;
        widgetMoveOrigins = selectedWidgets.map(w => ({ widget: w, origLeft: w.offsetLeft, origTop: w.offsetTop }));
        strokeMoveOrigins = selectedStrokes.map(s => ({ stroke: s, origPoints: s.points.map(p => ({...p})) }));
        document.addEventListener('mousemove', onMoveMove);
        document.addEventListener('mouseup',   onMoveEnd);
    };
    document.getElementById('sc-rotate-btn').ondblclick = (e) => {
        e.preventDefault(); e.stopPropagation();
        snapshotNow();
        selectedWidgets.forEach(w => {
            if (w.dataset.preRotLeft !== undefined) {
                w.style.left      = w.dataset.preRotLeft;
                w.style.top       = w.dataset.preRotTop;
                w.style.transform = w.dataset.preRotTransform || '';
                delete w.dataset.preRotLeft;
                delete w.dataset.preRotTop;
                delete w.dataset.preRotTransform;
            } else {
                w.style.transform = '';
            }
        });
        hideRotationIndicator();
        saveBoard(); updateSelectionOverlay();
    };
    document.getElementById('sc-rotate-btn').onmousedown = (e) => {
        e.preventDefault(); e.stopPropagation();
        snapshotNow();
        selectedWidgets.forEach(w => {
            if (w.dataset.preRotLeft === undefined) {
                w.dataset.preRotLeft      = w.style.left;
                w.dataset.preRotTop       = w.style.top;
                w.dataset.preRotTransform = w.style.transform || '';
            }
        });
        const center = getSelectionCenter();
        rotateCenterX = center.x; rotateCenterY = center.y;
        const br = board.getBoundingClientRect();
        rotateStartAngle = Math.atan2(e.clientY - br.top - rotateCenterY, e.clientX - br.left - rotateCenterX);
        rotateOrigWidgetTransforms = selectedWidgets.map(w => ({ widget: w, origLeft: w.offsetLeft, origTop: w.offsetTop, origRot: getCurrentRotation(w) }));
        rotateOrigStrokePoints = selectedStrokes.map(s => ({ stroke: s, origPoints: s.points.map(p => ({...p})) }));
        const indicator = document.getElementById('rotation-indicator');
        const onMove = (ev) => {
            const br2 = board.getBoundingClientRect();
            const angle = Math.atan2(ev.clientY - br2.top - rotateCenterY, ev.clientX - br2.left - rotateCenterX);
            const delta = (angle - rotateStartAngle) * 180 / Math.PI;
            rotateOrigWidgetTransforms.forEach(({ widget, origLeft, origTop, origRot }) => {
                const cx2 = origLeft + widget.offsetWidth/2  - rotateCenterX;
                const cy2 = origTop  + widget.offsetHeight/2 - rotateCenterY;
                const rad = delta * Math.PI / 180;
                widget.style.left      = (rotateCenterX + cx2*Math.cos(rad) - cy2*Math.sin(rad) - widget.offsetWidth/2)  + 'px';
                widget.style.top       = (rotateCenterY + cx2*Math.sin(rad) + cy2*Math.cos(rad) - widget.offsetHeight/2) + 'px';
                widget.style.transform = `rotate(${snapRotation(origRot + delta)}deg)`;
            });
            rotateOrigStrokePoints.forEach(({ stroke, origPoints }) => {
                const rad = delta * Math.PI / 180;
                stroke.points = origPoints.map(p => ({
                    x: rotateCenterX + (p.x-rotateCenterX)*Math.cos(rad) - (p.y-rotateCenterY)*Math.sin(rad),
                    y: rotateCenterY + (p.x-rotateCenterX)*Math.sin(rad) + (p.y-rotateCenterY)*Math.cos(rad)
                }));
            });
            if (indicator && rotateOrigWidgetTransforms.length > 0) {
                const deg = Math.round(((snapRotation(rotateOrigWidgetTransforms[0].origRot + delta) % 360) + 360) % 360);
                document.getElementById('rot-deg').textContent = deg + '¬∞';
                indicator.style.display = 'block';
                indicator.style.left = ev.clientX + 'px';
                indicator.style.top  = ev.clientY + 'px';
                indicator.querySelector('.rot-reset-hint').style.display = deg === 0 ? 'none' : 'inline';
            }
            if (drawCtx) redrawStrokes(); updateSelectionOverlay();
        };
        const onUp = () => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            hideRotationIndicator();
            saveBoard(); updateSelectionOverlay();
        };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    };
    document.getElementById('sc-delete-btn').onclick = (e) => {
        e.stopPropagation();
        snapshotNow();
        selectedWidgets.forEach(w => { w.classList.remove('selected'); w.remove(); });
        selectedWidgets = [];
        strokes = strokes.filter(s => !selectedStrokes.includes(s));
        selectedStrokes = [];
        if (drawCtx) redrawStrokes();
        document.getElementById('selection-controls').style.display = 'none';
        saveBoard();
    };
    document.getElementById('sc-menu-btn').onclick = (e) => {
        e.stopPropagation();
        const menu = document.getElementById('sc-ctx-menu');
        const isOpen = menu.classList.contains('open');
        menu.classList.toggle('open', !isOpen);
        if (!isOpen) buildScCtxMenu(menu);
    };
    // Bouton verrou de l'overlay groupe
    const scLockBtn = document.getElementById('sc-lock-btn');
    if (scLockBtn) {
        scLockBtn.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); });
        scLockBtn.addEventListener('click', e => {
            e.stopPropagation();
            const locked = scLockBtn.classList.toggle('locked');
            scLockBtn.textContent = locked ? 'üîí' : 'üîì';
        });
    }
    // Boutons sym√©trie de l'overlay groupe
    const scFlipH = document.getElementById('sc-flip-h-btn');
    const scFlipV = document.getElementById('sc-flip-v-btn');
    if (scFlipH) {
        scFlipH.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); });
        scFlipH.addEventListener('click', e => {
            e.stopPropagation(); snapshotNow();
            selectedWidgets.forEach(w => flipWidget(w, 'h'));
            flipStrokes(selectedStrokes, 'h');
            saveBoard();
        });
    }
    if (scFlipV) {
        scFlipV.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); });
        scFlipV.addEventListener('click', e => {
            e.stopPropagation(); snapshotNow();
            selectedWidgets.forEach(w => flipWidget(w, 'v'));
            flipStrokes(selectedStrokes, 'v');
            saveBoard();
        });
    }

    document.getElementById('sc-resize-btn').onmousedown = (e) => {
        e.preventDefault(); e.stopPropagation();
        const totalSel = selectedWidgets.length + selectedStrokes.length;
        if (totalSel < 1) return;
        snapshotNow();
        const br = board.getBoundingClientRect();
        let bMinX=Infinity, bMinY=Infinity, bMaxX=-Infinity, bMaxY=-Infinity;
        selectedWidgets.forEach(w => {
            const r = w.getBoundingClientRect();
            const l = r.left - br.left, t = r.top - br.top;
            const rr = r.right - br.left, rb = r.bottom - br.top;
            if (l  < bMinX) bMinX = l;  if (t  < bMinY) bMinY = t;
            if (rr > bMaxX) bMaxX = rr; if (rb > bMaxY) bMaxY = rb;
        });
        selectedStrokes.forEach(s => s.points.forEach(p => {
            if (p.x < bMinX) bMinX = p.x; if (p.y < bMinY) bMinY = p.y;
            if (p.x > bMaxX) bMaxX = p.x; if (p.y > bMaxY) bMaxY = p.y;
        }));
        const origBoxW = bMaxX - bMinX, origBoxH = bMaxY - bMinY;
        if (origBoxW < 1 || origBoxH < 1) return;
        const boxRatio = origBoxH / origBoxW;
        const startClientX = e.clientX, startClientY = e.clientY;
        const widgetOrigins = selectedWidgets.map(w => {
            const r = w.getBoundingClientRect();
            const wL = r.left  - br.left, wT = r.top    - br.top;
            const c = w.querySelector('.editor-container');
            const svg = w.querySelector('svg');
            return {
                widget: w,
                relL: (wL - bMinX) / origBoxW,
                relT: (wT - bMinY) / origBoxH,
                container: c,
                origCW: c   ? c.offsetWidth  : 0,
                origCH: c   ? c.offsetHeight : 0,
                svg: svg,
                origSW: svg ? parseFloat(svg.getAttribute('width')  || svg.getBoundingClientRect().width)  : 0,
                origSH: svg ? parseFloat(svg.getAttribute('height') || svg.getBoundingClientRect().height) : 0,
            };
        });
        const strokeOrigins = selectedStrokes.map(s => ({
            stroke: s,
            origPoints: s.points.map(p => ({ x: p.x, y: p.y }))
        }));
        const onMove = (ev) => {
            const proportional = ev.shiftKey || (scLockBtn && scLockBtn.classList.contains('locked'));
            const newBoxW = Math.max(20, origBoxW + ev.clientX - startClientX);
            const newBoxH = proportional ? Math.max(20, newBoxW * boxRatio)
                                         : Math.max(20, origBoxH + ev.clientY - startClientY);
            const scaleX = newBoxW / origBoxW, scaleY = newBoxH / origBoxH;
            widgetOrigins.forEach(({ widget, relL, relT, container, origCW, origCH, svg, origSW, origSH }) => {
                widget.style.left = (bMinX + relL * newBoxW) + 'px';
                widget.style.top  = (bMinY + relT * newBoxH) + 'px';
                if (container && origCW > 0) {
                    container.style.width  = (origCW * scaleX) + 'px';
                    container.style.height = (origCH * scaleY) + 'px';
                }
                if (svg && origSW > 0) {
                    const newSW = origSW * scaleX, newSH = origSH * scaleY;
                    svg.setAttribute('width', newSW); svg.setAttribute('height', newSH);
                    widget.style.width = newSW + 'px'; widget.style.height = newSH + 'px';
                }
            });
            strokeOrigins.forEach(({ stroke, origPoints }) => {
                stroke.points = origPoints.map(p => ({
                    x: bMinX + (p.x - bMinX) * scaleX,
                    y: bMinY + (p.y - bMinY) * scaleY
                }));
            });
            if (drawCtx) redrawStrokes();
            updateSelectionOverlay();
        };
        const onUp = () => {
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            const curW = window.innerWidth, curVH = virtualH(curW);
            selectedWidgets.forEach(w => {
                w.dataset.leftPercent = (w.offsetLeft / curW) * 100;
                w.dataset.topPercent  = (w.offsetTop  / curVH) * 100;
                const c = w.querySelector('.editor-container');
                if (c) {
                    w.dataset.widthPercent    = (c.offsetWidth  / curW) * 100;
                    w.dataset.contentHPercent = (c.offsetHeight / curVH) * 100;
                }
            });
            saveBoard();
        };
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onUp);
    };
    document.getElementById('sc-merge-btn').onclick = (e) => {
        e.stopPropagation();
        mergeWidgets();
    };
    document.getElementById('sc-ungroup-btn').onclick = (e) => {
        e.stopPropagation();
        const groupIds = new Set([
            ...selectedWidgets.map(w => w.dataset.groupId),
            ...selectedStrokes.map(s => s.groupId)
        ].filter(Boolean));
        if (groupIds.size === 0) return;
        snapshotNow();
        groupIds.forEach(gid => {
            document.querySelectorAll(`.widget[data-group-id="${gid}"], .shape-widget[data-group-id="${gid}"]`).forEach(w => {
                delete w.dataset.groupId;
            });
            strokes.filter(s => s.groupId === gid).forEach(s => { delete s.groupId; });
        });
        clearSelection();
        saveBoard();
    };
}

function buildScCtxMenu(menu) {
    menu.innerHTML = '';
    const addBtn = (label, fn) => {
        const b = document.createElement('button');
        b.innerHTML = label;
        b.onmousedown = ev => ev.stopPropagation();
        b.onclick = () => { menu.classList.remove('open'); fn(); };
        menu.appendChild(b);
    };
    const addSep = () => menu.appendChild(document.createElement('hr'));

    addBtn('‚¨ÜÔ∏è Premier plan', () => {
        snapshotNow();
        selectedWidgets.forEach(w => { pinnedZCounter++; w.style.zIndex = pinnedZCounter; });
        saveBoard();
    });
    addBtn('‚¨áÔ∏è Envoyer derri√®re', () => {
        snapshotNow();
        selectedWidgets.forEach(w => { w.style.zIndex = 1; w.dataset.background = "true"; w.dataset.pinned = "false"; w.classList.remove('pinned'); });
        saveBoard();
    });
    addSep();
    addBtn('‚ßâ Dupliquer', () => {
        snapshotNow();
        const toClone = [...selectedWidgets];
        clearSelection();
        toClone.forEach(w => {
            if (w.classList.contains('shape-widget')) cloneShapeWidget(w);
            else cloneWidget(w);
        });
    });
    const hasGroup = selectedWidgets.some(w => w.dataset.groupId);
    if (hasGroup) {
        const groupIds = new Set(selectedWidgets.map(w => w.dataset.groupId).filter(Boolean));
        addSep();
        addBtn('‚õìÔ∏è‚Äçüí• Dissocier le groupe', () => {
            snapshotNow();
            groupIds.forEach(gid => {
                document.querySelectorAll(`.widget[data-group-id="${gid}"], .shape-widget[data-group-id="${gid}"]`).forEach(w => {
                    delete w.dataset.groupId;
                });
            });
            clearSelection();
            saveBoard();
        });
    }
}

function onMoveMove(e) {
    const pos = getBoardPos(e);
    const dx = pos.x - moveStartX, dy = pos.y - moveStartY;
    widgetMoveOrigins.forEach(({ widget, origLeft, origTop }) => {
        widget.style.left = (origLeft + dx) + 'px'; widget.style.top = (origTop + dy) + 'px';
    });
    strokeMoveOrigins.forEach(({ stroke, origPoints }) => {
        stroke.points = origPoints.map(p => ({ x: p.x + dx, y: p.y + dy }));
    });
    if (drawCtx) redrawStrokes(); updateSelectionOverlay();
}

function onMoveEnd() {
    document.removeEventListener('mousemove', onMoveMove);
    document.removeEventListener('mouseup',   onMoveEnd);
    const curW = window.innerWidth, curVH = virtualH(curW);
    selectedWidgets.forEach(w => {
        w.dataset.leftPercent = (w.offsetLeft / curW) * 100;
        w.dataset.topPercent  = (w.offsetTop  / curVH) * 100;
    });
    saveBoard(); updateSelectionOverlay();
}

function getSelectionCenter() {
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const br = board.getBoundingClientRect();
    selectedWidgets.forEach(w => {
        const r = w.getBoundingClientRect();
        minX=Math.min(minX,r.left-br.left); minY=Math.min(minY,r.top-br.top);
        maxX=Math.max(maxX,r.right-br.left); maxY=Math.max(maxY,r.bottom-br.top);
    });
    selectedStrokes.forEach(s => s.points.forEach(p => {
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
    }));
    return { x:(minX+maxX)/2, y:(minY+maxY)/2 };
}

function updateSelectionOverlay() {
    const has = selectedWidgets.length > 0 || selectedStrokes.length > 0;
    const ctrl = document.getElementById('selection-controls');
    if (!has) {
        ctrl.style.display = 'none';
        board.classList.remove('single-select');
        return;
    }
    // Widget seul SANS groupe ‚Üí poign√©es natives bleues, pas d'overlay
    if (selectedWidgets.length === 1 && selectedStrokes.length === 0 && !selectedWidgets[0].dataset.groupId) {
        board.classList.add('single-select');
        board.classList.remove('multi-select');
        ctrl.style.display = 'none';
        return;
    }

    board.classList.remove('single-select');
    board.classList.add('multi-select');

    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    const br = board.getBoundingClientRect();
    selectedWidgets.forEach(w => {
        const r = w.getBoundingClientRect();
        minX=Math.min(minX,r.left-br.left); minY=Math.min(minY,r.top-br.top);
        maxX=Math.max(maxX,r.right-br.left); maxY=Math.max(maxY,r.bottom-br.top);
    });
    selectedStrokes.forEach(s => {
        const pad = (s.size||4)/2;
        s.points.forEach(p => {
            minX=Math.min(minX,p.x-pad); minY=Math.min(minY,p.y-pad);
            maxX=Math.max(maxX,p.x+pad); maxY=Math.max(maxY,p.y+pad);
        });
    });
    ctrl.style.display = 'block';
    ctrl.style.left   = minX + 'px'; ctrl.style.top    = minY + 'px';
    ctrl.style.width  = (maxX - minX) + 'px'; ctrl.style.height = (maxY - minY) + 'px';

    const resizeBtnO  = document.getElementById('sc-resize-btn');
    const scLockBtnO  = document.getElementById('sc-lock-btn');
    const scFlipHO    = document.getElementById('sc-flip-h-btn');
    const scFlipVO    = document.getElementById('sc-flip-v-btn');
    const mergeBtn    = document.getElementById('sc-merge-btn');
    const ungroupBtn  = document.getElementById('sc-ungroup-btn');
    if (resizeBtnO)  resizeBtnO.style.display  = '';
    if (scLockBtnO)  scLockBtnO.style.display  = 'flex';
    if (scFlipHO)    scFlipHO.style.display    = 'flex';
    if (scFlipVO)    scFlipVO.style.display    = 'flex';

    if (mergeBtn && ungroupBtn) {
        const totalSel  = selectedWidgets.length + selectedStrokes.length;
        const multi     = totalSel >= 2;
        const allGroupIds = [
            ...selectedWidgets.map(w => w.dataset.groupId),
            ...selectedStrokes.map(s => s.groupId)
        ].filter(Boolean);
        const groupIdSet   = new Set(allGroupIds);
        const allSameGroup = groupIdSet.size === 1 && allGroupIds.length === totalSel;

        if (allSameGroup) {
            mergeBtn.style.display   = 'none';
            ungroupBtn.style.display = 'flex';
        } else if (multi) {
            mergeBtn.style.display   = 'flex';
            ungroupBtn.style.display = 'none';
        } else {
            mergeBtn.style.display   = 'none';
            ungroupBtn.style.display = 'none';
        }
    }
}

function getBoardPos(e) {
    const r = board.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function findStrokeAt(x, y) {
    for (let i = strokes.length - 1; i >= 0; i--) {
        const s = strokes[i], tol = s.size / 2 + 5;
        for (let j = 1; j < s.points.length; j++) {
            if (distToSegment(x, y, s.points[j-1], s.points[j]) <= tol) return s;
        }
    }
    return null;
}

function distToSegment(px, py, a, b) {
    const dx = b.x-a.x, dy = b.y-a.y, lenSq = dx*dx + dy*dy;
    if (lenSq === 0) return Math.hypot(px-a.x, py-a.y);
    const t = Math.max(0, Math.min(1, ((px-a.x)*dx + (py-a.y)*dy) / lenSq));
    return Math.hypot(px - (a.x + t*dx), py - (a.y + t*dy));
}

// =========================================================================
// FORMATAGE TEXTE
// =========================================================================
function format(cmd, val=null) { document.execCommand(cmd, false, val); saveBoard(); }

function formatFontSize(size) {
    const sel = window.getSelection(); if (!sel || sel.rangeCount===0) return;
    document.execCommand("fontSize", false, "7");
    Array.from(document.getElementsByTagName("font")).forEach(f => {
        if (f.size === "7") { f.removeAttribute("size"); f.style.fontSize = size + "px"; }
    });
    saveBoard();
}

function formatFontFamily(font) {
    document.execCommand('fontName', false, font);
    const sel = window.getSelection();
    if (sel.anchorNode) sel.anchorNode.parentElement.style.fontFamily = font;
    saveBoard();
}

function changeWidgetBg(input, color) {
    const widget = input.closest('.widget');
    snapshotNow();
    applyTransparency(widget, false); widget.style.background = color; widget.dataset.bgColor = color; saveBoard();
}

function toggleTransparency(btn) {
    const widget = btn.closest('.widget');
    snapshotNow();
    applyTransparency(widget, widget.dataset.transparent !== "true"); saveBoard();
}

function applyTransparency(widget, isT) {
    const c = widget.querySelector('.editor-container');
    widget.dataset.transparent = isT;
    if (isT) { widget.style.background='transparent'; widget.style.boxShadow='none'; widget.style.border='none'; if(c) c.style.background='transparent'; }
    else { const bg = widget.dataset.bgColor||'#ffffff'; widget.style.background=''; widget.style.boxShadow=''; widget.style.border=''; if(c) c.style.background=bg; }
}

// =========================================================================
// PLEIN √âCRAN, YOUTUBE, IFRAME
// =========================================================================
function toggleFullScreen(el) {
    if (!document.fullscreenElement) el.requestFullscreen().catch(err => console.log(err));
    else document.exitFullscreen();
}
function loadIframe(input) {
    const iframe = input.closest('.editor-container').querySelector('iframe');
    let url = input.value.trim();
    if (url && !url.startsWith('http')) url = 'https://' + url;
    iframe.src = url; saveBoard();
}
function loadYoutube(input) {
    const iframe = input.closest('.editor-container').querySelector('iframe');
    let url = input.value.trim();
    const match = url.match(/(?:v=|youtu\.be\/|shorts\/)([a-zA-Z0-9_-]{11})/);
    iframe.src = match ? `https://www.youtube.com/embed/${match[1]}?autoplay=1` : url;
    saveBoard();
}
function toggleYoutubeView(btn, display) {
    const c = btn.closest('.editor-container');
    c.querySelector('iframe').style.display = display;
    c.style.height = display === 'none' ? '50px' : '';
    saveBoard();
}

// =========================================================================
// AGENDA
// =========================================================================
let dragSrcRow = null;
function handleRowDragStart(e) { dragSrcRow = this; this.classList.add('dragging'); }
function handleRowDragOver(e) {
    e.preventDefault(); if (!dragSrcRow || dragSrcRow===this) return;
    const list = this.parentNode, items = [...list.querySelectorAll('.agenda-item')];
    list.insertBefore(dragSrcRow, items.indexOf(dragSrcRow) < items.indexOf(this) ? this.nextSibling : this);
}
function handleRowDragEnd() { this.classList.remove('dragging'); dragSrcRow=null; saveBoard(); }
function addAgendaLine(btn) {
    snapshotNow();
    const list = btn.closest('.agenda-container').querySelector('.agenda-list');
    const item = document.createElement('div');
    item.className = 'agenda-item'; item.draggable = true;
    item.innerHTML = `<span class="agenda-row-handle">‚ãÆ‚ãÆ</span><span class="agenda-time" contenteditable="true">--:--</span><div class="agenda-text" contenteditable="true">Nouvelle ligne</div><span class="agenda-delete-row" onclick="deleteAgendaLine(this)" title="Supprimer">√ó</span>`;
    list.appendChild(item); attachAgendaItemEvents(item); saveBoard();
}
function deleteAgendaLine(btn) { snapshotNow(); btn.closest('.agenda-item').remove(); saveBoard(); }

// =========================================================================
// FOND
// =========================================================================
function applyBackground(value) {
    if (!value || value==='none') { board.style.background=''; board.style.backgroundColor='#eef2f5'; }
    else if (value.startsWith('#') || value.startsWith('rgb')) { board.style.background=''; board.style.backgroundColor=value; }
    else board.style.background = value;
}
function saveBg(value) { snapshotNow(); localStorage.setItem('boardBackground', value); }
function handleBgUpload(input) {
    const file = input.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => { const v = `url(${e.target.result})`; applyBackground(v); saveBg(v); };
    reader.readAsDataURL(file);
}
function toggleSubMenu(event) { event.stopPropagation(); document.getElementById('bg-submenu').classList.toggle('active'); }

// =========================================================================
// MENU
// =========================================================================
function toggleMenu() {
    document.getElementById('tools-menu').classList.toggle('active');
    document.getElementById('bg-submenu').classList.remove('active');
    document.getElementById('shape-toolbar').classList.remove('active');
    document.getElementById('shape-btn').style.background = '#eeeeee';
}
document.addEventListener('click', (e) => {
    if (!e.target.closest('#toolbar-container')) {
        document.getElementById('tools-menu').classList.remove('active');
        document.getElementById('bg-submenu').classList.remove('active');
        if (!e.target.closest('#shape-toolbar') && !e.target.closest('#shape-btn')) {
            document.getElementById('shape-toolbar').classList.remove('active');
            document.getElementById('shape-btn').style.background = '#eeeeee';
        }
    }
});

// =========================================================================
// BARRE TEXTE GLOBALE
// =========================================================================
let isTextPlacementMode = false;

function toggleGlobalToolbar() {
    const tb = document.getElementById('global-toolbar');
    const boardEl = document.getElementById('board');
    if (tb.style.display === 'none' || tb.style.display === '') {
        tb.style.display = 'block';
        isTextPlacementMode = true;
        boardEl.classList.add('cursor-pencil');
        if (typeof stopDrawing === "function") stopDrawing();
    } else {
        closeGlobalToolbar();
    }
}

function closeGlobalToolbar() {
    document.getElementById('global-toolbar').style.display = 'none';
    document.getElementById('board').classList.remove('cursor-pencil');
    isTextPlacementMode = false;
}

document.getElementById('board').addEventListener('click', function(e) {
    if (isTextPlacementMode && e.target.id === 'board') {
        const rect = this.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const widget = createWidget('text');
        widget.style.left = x + 'px'; widget.style.top = y + 'px';
        const editableArea = widget.querySelector('.editor-content');
        if (editableArea) setTimeout(() => editableArea.focus(), 10);
        isTextPlacementMode = false;
        this.classList.remove('cursor-pencil');
        saveBoard();
    } else if (e.target.id === 'board') {
        const tb = document.getElementById('global-toolbar');
        if (tb.style.display === 'block') closeGlobalToolbar();
    }
});

function formatGlobal(cmd, val=null) {
    if (!currentActiveWidget) return;
    if (savedSelection) { const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(savedSelection); savedSelection=null; }
    document.execCommand(cmd, false, val); saveBoard();
}

function formatFontSizeGlobal(size) {
    if (!currentActiveWidget) return;
    const editor = currentActiveWidget.querySelector('.editor-content'); if (!editor) return;
    if (savedSelection) { const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(savedSelection); }
    const sel = window.getSelection();
    if (sel && sel.rangeCount>0 && !sel.isCollapsed) {
        const range=sel.getRangeAt(0), span=document.createElement('span');
        span.style.fontSize = size+'px';
        try { range.surroundContents(span); } catch(e) { const f=range.extractContents(); span.appendChild(f); range.insertNode(span); }
        const nr=document.createRange(); nr.setStartAfter(span); nr.collapse(true);
        sel.removeAllRanges(); sel.addRange(nr);
    } else {
        editor.style.fontSize = size+'px';
        editor.querySelectorAll('*').forEach(el => { if (el.style.fontSize) el.style.fontSize=size+'px'; });
    }
    savedSelection=null; saveBoard();
}

function saveCurrentSelection() {
    const sel = window.getSelection();
    return (sel && sel.rangeCount>0) ? sel.getRangeAt(0).cloneRange() : null;
}

function formatFontFamilyGlobal(font) {
    if (!currentActiveWidget) return;
    document.execCommand('fontName', false, font);
    const sel = window.getSelection();
    if (sel.anchorNode) sel.anchorNode.parentElement.style.fontFamily = font;
    saveBoard();
}

function changeWidgetBgGlobal(input, color) {
    if (!currentActiveWidget) return;
    const c = currentActiveWidget.querySelector('.editor-container'); if (!c) return;
    snapshotNow();
    applyTransparency(currentActiveWidget, false); c.style.background=color; currentActiveWidget.dataset.bgColor=color; saveBoard();
}

function toggleTransparencyGlobal() {
    if (!currentActiveWidget) return;
    snapshotNow();
    applyTransparency(currentActiveWidget, currentActiveWidget.dataset.transparent!=="true"); saveBoard();
}

function applyTextColor(color) {
    if (!currentActiveWidget) return;
    if (savedSelection) { const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(savedSelection); savedSelection=null; }
    document.execCommand('foreColor', false, color); saveBoard();
}

function applyHighlightColor(color) {
    if (!currentActiveWidget) return;
    if (savedSelection) { const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(savedSelection); savedSelection=null; }
    document.execCommand('backColor', false, color); saveBoard();
}

function syncFontSizeGlobal() {
    if (!currentActiveWidget) return;
    const editor = currentActiveWidget.querySelector('.editor-content'); if (!editor) return;
    const sel = window.getSelection();
    let size = 40;
    if (sel.rangeCount>0) { const node=sel.anchorNode?.parentElement; if (node?.style.fontSize) size=parseInt(node.style.fontSize)||40; }
    else size = parseInt(window.getComputedStyle(editor).fontSize)||40;
    const inp = document.querySelector('#global-toolbar input[type="number"]');
    if (inp) inp.value = size;
}

function applyFontSizeOnBlur(input) {
    const size = parseInt(input.value);
    if (isNaN(size)||size<8) { input.value=8; return; }
    if (size>100) { input.value=100; return; }
    formatFontSizeGlobal(size);
    if (savedSelection) { const sel=window.getSelection(); sel.removeAllRanges(); sel.addRange(savedSelection); savedSelection=null; }
}

document.addEventListener('click', (e) => {
    const widget = e.target.closest('.widget');
    const isTextOrHomework = widget && (widget.dataset.type==='text' || widget.dataset.type==='homework');
    if (isTextOrHomework) { currentActiveWidget=widget; document.getElementById('global-toolbar').style.display='flex'; syncFontSizeGlobal(); return; }
    if (!e.target.closest('#global-toolbar') && !e.target.closest('#toolbar-toggle-btn') && !isTextOrHomework) {
        if (currentActiveWidget) { currentActiveWidget=null; document.getElementById('global-toolbar').style.display='none'; }
    }
});
</script>
</body>
</html>
